{
  "type": "step_start",
  "timestamp": 1768657099037,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2d991a001IVKMGnjWbLgwwI",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d86fd001zmC4x9NTstS39I",
    "type": "step-start",
    "snapshot": "ea85329fcb62a839f961b69bb2a962122b829df8"
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657099044,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2d991b001udHsmBwMadNGcv",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d86fd001zmC4x9NTstS39I",
    "type": "tool",
    "callID": "HPVEXvRYQ",
    "tool": "glob",
    "state": {
      "status": "completed",
      "input": {
        "pattern": "TODO.md"
      },
      "output": "No files found",
      "title": "",
      "metadata": {
        "count": 0,
        "truncated": false
      },
      "time": {
        "start": 1768657099037,
        "end": 1768657099044
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657099051,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2d9922001KfpLM3f7bEmHYu",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d86fd001zmC4x9NTstS39I",
    "type": "tool",
    "callID": "BjaUfsgg5",
    "tool": "grep",
    "state": {
      "status": "completed",
      "input": {
        "pattern": "TODO|FIXME|XXX|HACK"
      },
      "output": "Found 26 matches\n/home/heefoo/codeloom/.git/hooks/sendemail-validate.sample:\n  Line 22: # Replace the TODO placeholders with appropriate checks according to your\n  Line 27: \t# TODO: Replace with appropriate checks (e.g. spell checking).\n  Line 35: \t# TODO: Replace with appropriate checks for this patch\n  Line 41: \t# TODO: Replace with appropriate checks for the whole series\n  Line 52: \tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\n/home/heefoo/codeloom/internal/parser/grammars/julia/grammar.js:\n  Line 18:   'where', // FIXME\n  Line 265:     // TODO: Rename\n  Line 1111:     // FIXME: This is currently a seq to avoid conflicts with block_comment\n\n/home/heefoo/codeloom/internal/parser/grammars/commonlisp/test/corpus/basic.txt:\n  Line 582: Functions with numbers (TODO!!!)\n  Line 1232: Loop with keywords (TODO: do should not by type of with!)\n  Line 1278: with type should be symbol or list (TODO!!!)\n\n/home/heefoo/codeloom/internal/parser/grammars/commonlisp/queries/tags.scm:\n  Line 46: ;; TODO:\n  Line 94: ;;; TODO:\n  Line 98: ;;; TODO:\n\n/home/heefoo/codeloom/internal/parser/grammars/commonlisp/README.md:\n  Line 15: TODOs:\n\n/home/heefoo/codeloom/internal/parser/grammars/commonlisp/grammar.js:\n  Line 82: // XXX: not accounting for division by zero\n\n/home/heefoo/codeloom/internal/parser/grammars/clojure/grammar.js:\n  Line 75: // XXX: not constraining number before r/R\n  Line 76: // XXX: not constraining portion after r/R\n  Line 156: // XXX: better to match \\o378 as a single item\n  Line 171: // XXX: outside of: (c >= '\\uD800' && c <= '\\uDFFF') - LispReader.java\n  Line 180: // XXX: not quite sure what this is supposed to be...\n  Line 184: // XXX: null is supposed to be usable but putting \\x00 below\n  Line 222: // XXX: no attempt is made to enforce certain complex things, e.g.\n  Line 434:     // XXX: metadata here doesn't seem to make sense, but the repl\n  Line 457:         // XXX: symbol, reader conditional, and tagged literal can work\n  Line 509:     // XXX: metadata here doesn't seem to make sense, but the repl",
      "title": "TODO|FIXME|XXX|HACK",
      "metadata": {
        "matches": 26,
        "truncated": false
      },
      "time": {
        "start": 1768657099043,
        "end": 1768657099048
      }
    }
  }
}
{
  "type": "step_finish",
  "timestamp": 1768657099057,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2d992b001vH0XfkIGobaK58",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d86fd001zmC4x9NTstS39I",
    "type": "step-finish",
    "reason": "tool-calls",
    "snapshot": "ea85329fcb62a839f961b69bb2a962122b829df8",
    "cost": 0.039642,
    "tokens": {
      "input": 19671,
      "output": 50,
      "reasoning": 0,
      "cache": {
        "read": 0,
        "write": 0
      }
    }
  }
}
{
  "type": "step_start",
  "timestamp": 1768657110376,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc567001s3NBD4YbotLqki",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "step-start",
    "snapshot": "7bf7947e9424fa0f2b4cfa36cd2e4a25d63cbdda"
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110389,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc568001pyK45myIQbmRsF",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "wQc64lSMp",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/.git/hooks/sendemail-validate.sample"
      },
      "output": "<file>\n00001| #!/bin/sh\n00002| \n00003| # An example hook script to validate a patch (and/or patch series) before\n00004| # sending it via email.\n00005| #\n00006| # The hook should exit with non-zero status after issuing an appropriate\n00007| # message if it wants to prevent the email(s) from being sent.\n00008| #\n00009| # To enable this hook, rename this file to \"sendemail-validate\".\n00010| #\n00011| # By default, it will only check that the patch(es) can be applied on top of\n00012| # the default upstream branch without conflicts in a secondary worktree. After\n00013| # validation (successful or not) of the last patch of a series, the worktree\n00014| # will be deleted.\n00015| #\n00016| # The following config variables can be set to change the default remote and\n00017| # remote ref that are used to apply the patches against:\n00018| #\n00019| #   sendemail.validateRemote (default: origin)\n00020| #   sendemail.validateRemoteRef (default: HEAD)\n00021| #\n00022| # Replace the TODO placeholders with appropriate checks according to your\n00023| # needs.\n00024| \n00025| validate_cover_letter () {\n00026| \tfile=\"$1\"\n00027| \t# TODO: Replace with appropriate checks (e.g. spell checking).\n00028| \ttrue\n00029| }\n00030| \n00031| validate_patch () {\n00032| \tfile=\"$1\"\n00033| \t# Ensure that the patch applies without conflicts.\n00034| \tgit am -3 \"$file\" || return\n00035| \t# TODO: Replace with appropriate checks for this patch\n00036| \t# (e.g. checkpatch.pl).\n00037| \ttrue\n00038| }\n00039| \n00040| validate_series () {\n00041| \t# TODO: Replace with appropriate checks for the whole series\n00042| \t# (e.g. quick build, coding style checks, etc.).\n00043| \ttrue\n00044| }\n00045| \n00046| # main -------------------------------------------------------------------------\n00047| \n00048| if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\n00049| then\n00050| \tremote=$(git config --default origin --get sendemail.validateRemote) &&\n00051| \tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n00052| \tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n00053| \tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n00054| \tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n00055| else\n00056| \tworktree=$(git config --get sendemail.validateWorktree)\n00057| fi || {\n00058| \techo \"sendemail-validate: error: failed to prepare worktree\" >&2\n00059| \texit 1\n00060| }\n00061| \n00062| unset GIT_DIR GIT_WORK_TREE\n00063| cd \"$worktree\" &&\n00064| \n00065| if grep -q \"^diff --git \" \"$1\"\n00066| then\n00067| \tvalidate_patch \"$1\"\n00068| else\n00069| \tvalidate_cover_letter \"$1\"\n00070| fi &&\n00071| \n00072| if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\n00073| then\n00074| \tgit config --unset-all sendemail.validateWorktree &&\n00075| \ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n00076| \tvalidate_series\n00077| fi\n00078| \n\n(End of file - total 78 lines)\n</file>",
      "title": ".git/hooks/sendemail-validate.sample",
      "metadata": {
        "preview": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n# message if it wants to prevent the email(s) from being sent.\n#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n#\n# The following config variables can be set to change the default remote and\n# remote ref that are used to apply the patches against:\n#\n#   sendemail.validateRemote (default: origin)\n#   sendemail.validateRemoteRef (default: HEAD)",
        "truncated": false
      },
      "time": {
        "start": 1768657110377,
        "end": 1768657110389
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110390,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc56a001eE0HZUl1jrzUAi",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "FVA04bGGN",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/internal/parser/grammars/julia/grammar.js"
      },
      "output": "<file>\n00001| /**\n00002|  * @file Julia grammar for tree-sitter\n00003|  * @author Max Brunsfeld <maxbrunsfeld@gmail.com>\n00004|  * @author Sergio A. Vargas <savargasqu+git@unal.edu.co>\n00005|  * @license MIT\n00006|  */\n00007| \n00008| /// <reference types=\"tree-sitter-cli/dsl\" />\n00009| // @ts-check\n00010| \n00011| const PREC = [\n00012|   'afunc',\n00013|   'pair',\n00014|   'conditional',\n00015|   'arrow',\n00016|   'lazy_or',\n00017|   'lazy_and',\n00018|   'where', // FIXME\n00019|   'comparison',\n00020|   'pipe_left',\n00021|   'pipe_right',\n00022|   'colon',\n00023|   'plus',\n00024|   'times',\n00025|   'rational',\n00026|   'bitshift',\n00027|   'prefix',\n00028|   'power',\n00029|   'decl',\n00030|   'dot',\n00031| ].reduce((result, name, index) => {\n00032|   result[name] = index + 10;\n00033|   return result;\n00034| }, {});\n00035| \n00036| PREC.array = -1;\n00037| PREC.tuple = -1;\n00038| PREC.assign = -2;\n00039| PREC.stmt = -3;\n00040| PREC.macro_arg = -4;\n00041| \n00042| const OPERATORS = {\n00043|   assignment: `\n00044|     += -= *= /= //= \\\\= ^= %= <<= >>= >>>= |= &=\n00045|     −= ÷= ⊻= ≔ ⩴ ≕\n00046|   `,\n00047| \n00048|   arrow: `\n00049|     <-- --> <-->\n00050|     ← → ↔ ↚ ↛ ↞ ↠ ↢ ↣ ↦ ↤ ↮ ⇎ ⇍ ⇏ ⇐ ⇒ ⇔ ⇴ ⇶ ⇷ ⇸ ⇹ ⇺ ⇻ ⇼ ⇽ ⇾ ⇿ ⟵ ⟶ ⟷ ⟹ ⟺ ⟻ ⟼ ⟽ ⟾ ⟿\n00051|     ⤀ ⤁ ⤂ ⤃ ⤄ ⤅ ⤆ ⤇ ⤌ ⤍ ⤎ ⤏ ⤐ ⤑ ⤔ ⤕ ⤖ ⤗ ⤘ ⤝ ⤞ ⤟ ⤠ ⥄ ⥅ ⥆ ⥇ ⥈ ⥊ ⥋ ⥎ ⥐ ⥒ ⥓ ⥖ ⥗ ⥚ ⥛ ⥞\n00052|     ⥟ ⥢ ⥤ ⥦ ⥧ ⥨ ⥩ ⥪ ⥫ ⥬ ⥭ ⥰ ⧴ ⬱ ⬰ ⬲ ⬳ ⬴ ⬵ ⬶ ⬷ ⬸ ⬹ ⬺ ⬻ ⬼ ⬽ ⬾ ⬿ ⭀ ⭁ ⭂ ⭃ ⥷ ⭄ ⥺ ⭇ ⭈ ⭉\n00053|     ⭊ ⭋ ⭌ ￩ ￫ ⇜ ⇝ ↜ ↝ ↩ ↪ ↫ ↬ ↼ ↽ ⇀ ⇁ ⇄ ⇆ ⇇ ⇉ ⇋ ⇌ ⇚ ⇛ ⇠ ⇢ ↷ ↶ ↺ ↻\n00054|   `,\n00055| \n00056|   comparison: `\n00057|     > < >= <= == === != !==\n00058|     ≥ ≤ ≡ ≠ ≢ ∈ ∉ ∋ ∌ ⊆ ⊈ ⊂ ⊄ ⊊ ∝ ∊ ∍ ∥ ∦ ∷ ∺ ∻ ∽ ∾ ≁ ≃ ≂ ≄ ≅ ≆ ≇ ≈ ≉ ≊ ≋ ≌ ≍ ≎ ≐\n00059|     ≑ ≒ ≓ ≖ ≗ ≘ ≙ ≚ ≛ ≜ ≝ ≞ ≟ ≣ ≦ ≧ ≨ ≩ ≪ ≫ ≬ ≭ ≮ ≯ ≰ ≱ ≲ ≳ ≴ ≵ ≶ ≷ ≸ ≹ ≺ ≻ ≼ ≽ ≾\n00060|     ≿ ⊀ ⊁ ⊃ ⊅ ⊇ ⊉ ⊋ ⊏ ⊐ ⊑ ⊒ ⊜ ⊩ ⊬ ⊮ ⊰ ⊱ ⊲ ⊳ ⊴ ⊵ ⊶ ⊷ ⋍ ⋐ ⋑ ⋕ ⋖ ⋗ ⋘ ⋙ ⋚ ⋛ ⋜ ⋝ ⋞ ⋟ ⋠\n00061|     ⋡ ⋢ ⋣ ⋤ ⋥ ⋦ ⋧ ⋨ ⋩ ⋪ ⋫ ⋬ ⋭ ⋲ ⋳ ⋴ ⋵ ⋶ ⋷ ⋸ ⋹ ⋺ ⋻ ⋼ ⋽ ⋾ ⋿ ⟈ ⟉ ⟒ ⦷ ⧀ ⧁ ⧡ ⧣ ⧤ ⧥ ⩦ ⩧\n00062|     ⩪ ⩫ ⩬ ⩭ ⩮ ⩯ ⩰ ⩱ ⩲ ⩳ ⩵ ⩶ ⩷ ⩸ ⩹ ⩺ ⩻ ⩼ ⩽ ⩾ ⩿ ⪀ ⪁ ⪂ ⪃ ⪄ ⪅ ⪆ ⪇ ⪈ ⪉ ⪊ ⪋ ⪌ ⪍ ⪎ ⪏ ⪐ ⪑\n00063|     ⪒ ⪓ ⪔ ⪕ ⪖ ⪗ ⪘ ⪙ ⪚ ⪛ ⪜ ⪝ ⪞ ⪟ ⪠ ⪡ ⪢ ⪣ ⪤ ⪥ ⪦ ⪧ ⪨ ⪩ ⪪ ⪫ ⪬ ⪭ ⪮ ⪯ ⪰ ⪱ ⪲ ⪳ ⪴ ⪵ ⪶ ⪷ ⪸\n00064|     ⪹ ⪺ ⪻ ⪼ ⪽ ⪾ ⪿ ⫀ ⫁ ⫂ ⫃ ⫄ ⫅ ⫆ ⫇ ⫈ ⫉ ⫊ ⫋ ⫌ ⫍ ⫎ ⫏ ⫐ ⫑ ⫒ ⫓ ⫔ ⫕ ⫖ ⫗ ⫘ ⫙ ⫷ ⫸ ⫹ ⫺ ⊢ ⊣\n00065|     ⟂ ⫪ ⫫\n00066|   `,\n00067| \n00068|   ellipsis: '… ⁝ ⋮ ⋱ ⋰ ⋯',\n00069| \n00070|   plus: `\n00071|     ++ |\n00072|     − ¦ ⊕ ⊖ ⊞ ⊟ ∪ ∨ ⊔ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⟇ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅\n00073|     ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣\n00074|   `,\n00075| \n00076|   times: `\n00077|     * / % & \\\\\n00078|     ⌿ ÷ · · ⋅ ∘ × ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ ∗ ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷\n00079|     ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗ ⨟\n00080|   `,\n00081| \n00082|   bitshift: '<< >> >>>',\n00083| \n00084|   power: `\n00085|     ^\n00086|     ↑ ↓ ⇵ ⟰ ⟱ ⤈ ⤉ ⤊ ⤋ ⤒ ⤓ ⥉ ⥌ ⥍ ⥏ ⥑ ⥔ ⥕ ⥘ ⥙ ⥜ ⥝ ⥠ ⥡ ⥣ ⥥ ⥮ ⥯ ￪ ￬\n00087|   `,\n00088| \n00089|   unary: '! ¬ √ ∛ ∜',\n00090| \n00091|   unary_plus: '+ - ± ∓',\n00092| };\n00093| \n00094| const ESCAPE_SEQUENCE = token(seq(\n00095|   '\\\\',\n00096|   choice(\n00097|     /[^uUx0-7]/,\n00098|     /[uU][0-9a-fA-F]{1,6}/, // unicode codepoints\n00099|     /[0-7]{1,3}/,\n00100|     /x[0-9a-fA-F]{2}/,\n00101|   ),\n00102| ));\n00103| \n00104| // Keywords that can be quoted. Some still fail depending on the context.\n00105| const KEYWORDS = choice(\n00106|   'baremodule',\n00107|   'module',\n00108|   'abstract',\n00109|   'primitive',\n00110|   'mutable',\n00111|   'struct',\n00112|   'quote',\n00113|   'let',\n00114|   'if',\n00115|   'else',\n00116|   'elseif',\n00117|   'try',\n00118|   'catch',\n00119|   'finally',\n00120|   'for',\n00121|   'while',\n00122|   'break',\n00123|   'continue',\n00124|   'using',\n00125|   'import',\n00126|   'const',\n00127|   'global',\n00128|   'local',\n00129|   'end',\n00130| );\n00131| \n00132| module.exports = grammar({\n00133|   name: 'julia',\n00134| \n00135|   word: $ => $._word_identifier,\n00136| \n00137|   inline: $ => [\n00138|     $._block_form,\n00139|     $._terminator,\n00140|     $._definition,\n00141|     $._statement,\n00142|     $._operation,\n00143|   ],\n00144| \n00145|   externals: $ => [\n00146|     $._block_comment_rest,\n00147|     $._immediate_paren,\n00148|     $._immediate_bracket,\n00149|     $._immediate_brace,\n00150|     $._immediate_string_start,\n00151|     $._immediate_command_start,\n00152|     $._content_cmd_1,\n00153|     $._content_cmd_1_raw,\n00154|     $._content_cmd_3,\n00155|     $._content_cmd_3_raw,\n00156|     $._content_str_1,\n00157|     $._content_str_1_raw,\n00158|     $._content_str_3,\n00159|     $._content_str_3_raw,\n00160|     $._end_cmd,\n00161|     $._end_str,\n00162|   ],\n00163| \n00164|   conflicts: $ => [\n00165|     [$.juxtaposition_expression, $._primary_expression], // adjoint\n00166|     [$.juxtaposition_expression, $._expression],\n00167|     [$.matrix_row, $.comprehension_expression], // Comprehensions with newlines\n00168|     [$.parenthesized_expression, $.tuple_expression],\n00169|   ],\n00170| \n00171|   supertypes: $ => [\n00172|     $._expression,\n00173|     $._statement,\n00174|     $._definition,\n00175|   ],\n00176| \n00177|   extras: $ => [\n00178|     /\\s/,\n00179|     $.line_comment,\n00180|     $.block_comment,\n00181|   ],\n00182| \n00183|   rules: {\n00184|     source_file: $ => optional($._block),\n00185| \n00186|     _block: $ => seq(\n00187|       sep1($._terminator, $._block_form),\n00188|       optional($._terminator)\n00189|     ),\n00190| \n00191|     _block_form: $ => choice(\n00192|       $._expression,\n00193|       $.assignment,\n00194|       $.open_tuple,\n00195|     ),\n00196| \n00197|     _bracket_form: $ => choice(\n00198|       $._expression,\n00199|       alias($._closed_assignment, $.assignment),\n00200|     ),\n00201| \n00202|     open_tuple: $ => prec(PREC.tuple, seq(\n00203|       $._expression,\n00204|       repeat1(seq(',', $._expression))\n00205|     )),\n00206| \n00207|     // assignments inside blocks\n00208|     assignment: $ => prec.right(PREC.assign, seq(\n00209|       choice(\n00210|         $._primary_expression,\n00211|         $.open_tuple,\n00212|         $._operation,\n00213|         $.operator,\n00214|       ),\n00215|       alias('=', $.operator),\n00216|       $._block_form,\n00217|     )),\n00218| \n00219|     // assignments inside brackets\n00220|     _closed_assignment: $ => prec.right(PREC.assign, seq(\n00221|       choice(\n00222|         $._primary_expression,\n00223|         $._operation,\n00224|         $.operator,\n00225|       ),\n00226|       alias('=', $.operator),\n00227|       $._bracket_form,\n00228|     )),\n00229| \n00230|     _expression: $ => choice(\n00231|       $._definition,\n00232|       $._statement,\n00233|       $._primary_expression,\n00234|       $._operation,\n00235|       $.compound_assignment_expression,\n00236|       $.macrocall_expression,\n00237|       $.arrow_function_expression,\n00238|       $.juxtaposition_expression,\n00239|       $.ternary_expression,\n00240|       $.operator,\n00241|       $.integer_literal,\n00242|       $.float_literal,\n00243|       prec(-1, alias('begin', $.identifier)),\n00244|     ),\n00245| \n00246|     // Definitions\n00247| \n00248|     _definition: $ => choice(\n00249|       $.module_definition,\n00250|       $.abstract_definition,\n00251|       $.primitive_definition,\n00252|       $.struct_definition,\n00253|       $.function_definition,\n00254|       $.macro_definition,\n00255|     ),\n00256| \n00257|     module_definition: $ => seq(\n00258|       choice('module', 'baremodule'),\n00259|       field('name', choice($.identifier, $.interpolation_expression)),\n00260|       optional($._terminator),\n00261|       optional($._block),\n00262|       'end',\n00263|     ),\n00264| \n00265|     // TODO: Rename\n00266|     type_head: $ => prec(PREC.stmt, choice(\n00267|       $._primary_expression,\n00268|       $.binary_expression,\n00269|     )),\n00270| \n00271|     abstract_definition: $ => seq(\n00272|       'abstract',\n00273|       'type',\n00274|       $.type_head,\n00275|       'end',\n00276|     ),\n00277| \n00278|     primitive_definition: $ => seq(\n00279|       'primitive',\n00280|       'type',\n00281|       $.type_head,\n00282|       $.integer_literal,\n00283|       'end',\n00284|     ),\n00285| \n00286|     struct_definition: $ => seq(\n00287|       optional('mutable'),\n00288|       'struct',\n00289|       $.type_head,\n00290|       optional($._terminator),\n00291|       optional($._block),\n00292|       'end',\n00293|     ),\n00294| \n00295|     signature: $ => prec(PREC.stmt, choice(\n00296|       $.identifier, // zero-method definition\n00297|       $.call_expression,\n00298|       alias($.tuple_expression, $.argument_list), // anonymous function\n00299|       $.typed_expression,\n00300|       $.where_expression,\n00301|     )),\n00302| \n00303|     function_definition: $ => seq(\n00304|       'function',\n00305|       $.signature,\n00306|       optional($._terminator),\n00307|       optional($._block),\n00308|       'end',\n00309|     ),\n00310| \n00311|     macro_definition: $ => seq(\n00312|       'macro',\n00313|       $.signature,\n00314|       optional($._terminator),\n00315|       optional($._block),\n00316|       'end',\n00317|     ),\n00318| \n00319| \n00320|     // Statements\n00321| \n00322|     _statement: $ => choice(\n00323|       // block statements:\n00324|       $.compound_statement,\n00325|       $.quote_statement,\n00326|       $.let_statement,\n00327|       $.if_statement,\n00328|       $.try_statement,\n00329|       $.for_statement,\n00330|       $.while_statement,\n00331|       // simple statements:\n00332|       $.break_statement,\n00333|       $.continue_statement,\n00334|       $.return_statement,\n00335|       $.const_statement,\n00336|       $.global_statement,\n00337|       $.local_statement,\n00338|       $.export_statement,\n00339|       $.import_statement,\n00340|       $.public_statement,\n00341|       $.using_statement,\n00342|     ),\n00343| \n00344|     compound_statement: $ => seq('begin', optional($._terminator), optional($._block), 'end'),\n00345| \n00346|     quote_statement: $ => seq('quote', optional($._terminator), optional($._block), 'end'),\n00347| \n00348|     let_statement: $ => seq(\n00349|       'let',\n00350|       sep(',', $._bracket_form),\n00351|       $._terminator,\n00352|       optional($._block),\n00353|       'end',\n00354|     ),\n00355| \n00356|     if_statement: $ => seq(\n00357|       'if',\n00358|       field('condition', $._expression),\n00359|       optional($._terminator),\n00360|       optional($._block),\n00361|       field('alternative', repeat($.elseif_clause)),\n00362|       field('alternative', optional($.else_clause)),\n00363|       'end',\n00364|     ),\n00365| \n00366|     elseif_clause: $ => seq(\n00367|       'elseif',\n00368|       field('condition', $._expression),\n00369|       optional($._terminator),\n00370|       optional($._block),\n00371|     ),\n00372| \n00373|     else_clause: $ => seq(\n00374|       'else',\n00375|       optional($._terminator),\n00376|       optional($._block),\n00377|     ),\n00378| \n00379|     try_statement: $ => seq(\n00380|       'try',\n00381|       optional($._terminator),\n00382|       optional($._block),\n00383|       choice(\n00384|         seq(\n00385|           $.catch_clause,\n00386|           optional($.else_clause),\n00387|           optional($.finally_clause),\n00388|         ),\n00389|         seq(\n00390|           $.finally_clause,\n00391|           optional($.catch_clause),\n00392|           // `else` is not valid here.\n00393|         ),\n00394|       ),\n00395|       'end',\n00396|     ),\n00397| \n00398|     catch_clause: $ => prec(1, seq(\n00399|       'catch',\n00400|       optional($.identifier),\n00401|       optional($._terminator),\n00402|       optional($._block),\n00403|     )),\n00404| \n00405|     finally_clause: $ => seq(\n00406|       'finally',\n00407|       optional($._terminator),\n00408|       optional($._block),\n00409|     ),\n00410| \n00411|     for_statement: $ => seq(\n00412|       'for',\n00413|       sep1(',', $.for_binding),\n00414|       optional($._terminator),\n00415|       optional($._block),\n00416|       'end',\n00417|     ),\n00418| \n00419|     while_statement: $ => seq(\n00420|       'while',\n00421|       field('condition', $._expression),\n00422|       optional($._terminator),\n00423|       optional($._block),\n00424|       'end',\n00425|     ),\n00426| \n00427|     break_statement: _ => 'break',\n00428| \n00429|     continue_statement: _ => 'continue',\n00430| \n00431|     return_statement: $ => prec.right(PREC.stmt, seq(\n00432|       'return',\n00433|       optional($._block_form),\n00434|     )),\n00435| \n00436|     const_statement: $ => prec.right(PREC.stmt, seq(\n00437|       'const',\n00438|       $._block_form,\n00439|     )),\n00440| \n00441|     global_statement: $ => prec.right(PREC.stmt, seq(\n00442|       'global',\n00443|       $._block_form,\n00444|     )),\n00445| \n00446|     local_statement: $ => prec.right(PREC.stmt, seq(\n00447|       'local',\n00448|       $._block_form,\n00449|     )),\n00450| \n00451|     import_alias: $ => seq($._importable, 'as', $._exportable),\n00452| \n00453|     import_path: $ => seq(\n00454|       token(repeat1('.')),\n00455|       choice(\n00456|         $.identifier,\n00457|         $._scoped_identifier,\n00458|       ),\n00459|     ),\n00460| \n00461|     _exportable: $ => choice(\n00462|       $.identifier,\n00463|       $.macro_identifier,\n00464|       $.operator,\n00465|       $.interpolation_expression,\n00466|       parenthesize($._exportable),\n00467|     ),\n00468| \n00469|     _importable: $ => choice(\n00470|       $._exportable,\n00471|       alias($._scoped_identifier, $.import_path),\n00472|       $.import_path,\n00473|     ),\n00474| \n00475|     _import_list: $ => prec.right(sep1(',', choice(\n00476|       $._importable,\n00477|       $.import_alias,\n00478|     ))),\n00479| \n00480|     selected_import: $ => seq(\n00481|       $._importable,\n00482|       token.immediate(':'),\n00483|       $._import_list,\n00484|     ),\n00485| \n00486|     export_statement: $ => seq('export', prec.right(sep1(',', $._exportable))),\n00487| \n00488|     public_statement: $ => seq('public', prec.right(sep1(',', $._exportable))),\n00489| \n00490|     import_statement: $ => seq(\n00491|       'import',\n00492|       choice(\n00493|         $._import_list,\n00494|         $.selected_import,\n00495|       ),\n00496|     ),\n00497| \n00498|     using_statement: $ => seq(\n00499|       'using',\n00500|       choice(\n00501|         $._import_list,\n00502|         $.selected_import,\n00503|       ),\n00504|     ),\n00505| \n00506|     // Primary expressions can be called, indexed, accessed, and type parametrized.\n00507|     _primary_expression: $ => choice(\n00508|       $.identifier,\n00509|       $.boolean_literal,\n00510|       $.curly_expression, // Only valid in macros\n00511|       $.parenthesized_expression,\n00512|       $.tuple_expression,\n00513|       $._array,\n00514|       $._string,\n00515|       $.adjoint_expression,\n00516|       $.broadcast_call_expression,\n00517|       $.call_expression,\n00518|       alias($._closed_macrocall_expression, $.macrocall_expression),\n00519|       $.parametrized_type_expression,\n00520|       $.field_expression,\n00521|       $.index_expression,\n00522|       $.interpolation_expression,\n00523|       $.quote_expression,\n00524|     ),\n00525| \n00526|     _array: $ => choice(\n00527|       $.comprehension_expression,\n00528|       $.matrix_expression,\n00529|       $.vector_expression,\n00530|     ),\n00531| \n00532|     comprehension_expression: $ => prec(PREC.array, seq(\n00533|       '[',\n00534|       $._bracket_form,\n00535|       optional($._terminator),\n00536|       $.for_clause,\n00537|       repeat(choice(\n00538|         $.for_clause,\n00539|         $.if_clause,\n00540|       )),\n00541|       ']',\n00542|     )),\n00543| \n00544|     generator: $ => seq(\n00545|       $._bracket_form,\n00546|       $.for_clause,\n00547|       repeat(choice(\n00548|         $.for_clause,\n00549|         $.if_clause,\n00550|       )),\n00551|     ),\n00552| \n00553|     if_clause: $ => seq(\n00554|       'if',\n00555|       $._expression,\n00556|     ),\n00557| \n00558|     for_clause: $ => prec.right(seq(\n00559|       'for',\n00560|       sep1(',', $.for_binding),\n00561|     )),\n00562| \n00563|     for_binding: $ => prec(1, seq(\n00564|       optional('outer'),\n00565|       choice(\n00566|         $.identifier,\n00567|         $.tuple_expression,\n00568|         $.typed_expression,\n00569|         $.interpolation_expression,\n00570|       ),\n00571|       alias(choice('in', '=', '∈'), $.operator),\n00572|       $._expression,\n00573|     )),\n00574| \n00575|     matrix_expression: $ => prec(PREC.array, seq(\n00576|       '[',\n00577|       $.matrix_row,\n00578|       repeat(seq($._terminator, $.matrix_row)),\n00579|       optional($._terminator),\n00580|       ']',\n00581|     )),\n00582| \n00583|     matrix_row: $ => repeat1(prec(PREC.array, $._bracket_form)),\n00584| \n00585|     vector_expression: $ => seq(\n00586|       '[',\n00587|       sep(',', $._bracket_form),\n00588|       optional(','),\n00589|       ']',\n00590|     ),\n00591| \n00592|     parenthesized_expression: $ => prec.dynamic(1, parenthesize(\n00593|       sep1($._semicolon, choice(\n00594|         $._bracket_form,\n00595|         $.generator,\n00596|       )),\n00597|       optional($._semicolon),\n00598|     )),\n00599| \n00600|     tuple_expression: $ => parenthesize(\n00601|       optional($._semicolon),\n00602|       sep(choice(',', $._semicolon), choice(\n00603|         $._bracket_form,\n00604|         $.generator,\n00605|       )),\n00606|       optional(','),\n00607|     ),\n00608| \n00609|     curly_expression: $ => seq(\n00610|       '{',\n00611|       sep(',', $._bracket_form),\n00612|       optional(','),\n00613|       '}',\n00614|     ),\n00615| \n00616|     adjoint_expression: $ => seq(\n00617|       $._primary_expression,\n00618|       token.immediate('\\''),\n00619|     ),\n00620| \n00621|     field_expression: $ => prec(PREC.dot, seq(\n00622|       field('value', $._primary_expression),\n00623|       token.immediate('.'),\n00624|       choice(\n00625|         $.identifier,\n00626|         $.interpolation_expression,\n00627|         $.quote_expression,\n00628|         $._string,\n00629|       ),\n00630|     )),\n00631| \n00632|     index_expression: $ => seq(\n00633|       $._primary_expression,\n00634|       $._immediate_bracket,\n00635|       $._array,\n00636|     ),\n00637| \n00638|     parametrized_type_expression: $ => seq(\n00639|       $._primary_expression,\n00640|       $._immediate_brace,\n00641|       $.curly_expression,\n00642|     ),\n00643| \n00644|     call_expression: $ => seq(\n00645|       choice($._primary_expression, $.operator),\n00646|       $._immediate_paren,\n00647|       alias($.tuple_expression, $.argument_list),\n00648|       optional($.do_clause),\n00649|     ),\n00650| \n00651|     broadcast_call_expression: $ => seq(\n00652|       $._primary_expression,\n00653|       token.immediate('.'),\n00654|       $._immediate_paren,\n00655|       alias($.tuple_expression, $.argument_list),\n00656|       optional($.do_clause),\n00657|     ),\n00658| \n00659|     _qualified_macro_identifier: $ => seq(\n00660|       $._primary_expression,\n00661|       token.immediate('.'),\n00662|       $.macro_identifier,\n00663|     ),\n00664| \n00665|     _macro_head: $ => choice(\n00666|       alias($._qualified_macro_identifier, $.field_expression),\n00667|       $.macro_identifier,\n00668|     ),\n00669| \n00670|     _closed_macrocall_expression: $ => seq(\n00671|       $._macro_head,\n00672|       choice(\n00673|         seq($._immediate_brace, $.curly_expression),\n00674|         seq($._immediate_bracket, $._array),\n00675|         seq(\n00676|           $._immediate_paren,\n00677|           alias($.tuple_expression, $.argument_list),\n00678|           optional($.do_clause)\n00679|         ),\n00680|       ),\n00681|     ),\n00682| \n00683|     macrocall_expression: $ => prec.right(seq($._macro_head, optional($.macro_argument_list))),\n00684| \n00685|     macro_argument_list: $ => prec.left(repeat1(prec(PREC.macro_arg, $._block_form))),\n00686| \n00687|     do_clause: $ => seq(\n00688|       'do',\n00689|       sep(',', $._bracket_form),\n00690|       $._terminator,\n00691|       optional($._block),\n00692|       'end',\n00693|     ),\n00694| \n00695|     interpolation_expression: $ => prec.right(PREC.prefix, seq(\n00696|       '$',\n00697|       choice(\n00698|         $.integer_literal,\n00699|         $.float_literal,\n00700|         $.identifier,\n00701|         $.curly_expression,\n00702|         $.parenthesized_expression,\n00703|         $.tuple_expression,\n00704|         $._array,\n00705|         $._string,\n00706|       ),\n00707|     )),\n00708| \n00709|     quote_expression: $ => prec.right(PREC.prefix, seq(\n00710|       ':',\n00711|       choice(\n00712|         $.integer_literal,\n00713|         $.float_literal,\n00714|         $._string,\n00715|         $.identifier,\n00716|         $.operator,\n00717|         seq($._immediate_brace, $.curly_expression),\n00718|         seq($._immediate_bracket, $._array),\n00719|         seq($._immediate_paren, choice(\n00720|           $.parenthesized_expression,\n00721|           $.tuple_expression,\n00722|           // Syntactic operators in parentheses\n00723|           parenthesize(\n00724|             alias(\n00725|               choice(\n00726|                 '::', ':=', '.=', '=',\n00727|                 $._assignment_operator,\n00728|                 $._lazy_or_operator,\n00729|                 $._lazy_and_operator,\n00730|                 $._syntactic_operator,\n00731|               ),\n00732|               $.operator,\n00733|             ),\n00734|           ),\n00735|         )),\n00736|         // Syntactic operators without parentheses\n00737|         alias(\n00738|           choice(\n00739|             $._assignment_operator,\n00740|             $._lazy_or_operator,\n00741|             $._lazy_and_operator,\n00742|             $._syntactic_operator,\n00743|           ),\n00744|           $.operator,\n00745|         ),\n00746|         alias(token.immediate(KEYWORDS), $.identifier),\n00747|       ),\n00748|     )),\n00749| \n00750| \n00751|     // Operations\n00752| \n00753|     _operation: $ => choice(\n00754|       $.unary_expression,\n00755|       $.binary_expression,\n00756|       $.range_expression,\n00757|       $.splat_expression,\n00758|       $.typed_expression,\n00759|       $.unary_typed_expression,\n00760|       $.where_expression,\n00761|     ),\n00762| \n00763|     binary_expression: $ => {\n00764|       const table = [\n00765|         [prec.right, PREC.pair, $._pair_operator],\n00766|         [prec.right, PREC.arrow, $._arrow_operator],\n00767|         [prec.left, PREC.lazy_or, $._lazy_or_operator],\n00768|         [prec.left, PREC.lazy_and, $._lazy_and_operator],\n00769|         [prec.left, PREC.comparison, choice('in', 'isa', $._comparison_operator, $._type_order_operator)],\n00770|         [prec.right, PREC.pipe_left, $._pipe_left_operator],\n00771|         [prec.left, PREC.pipe_right, $._pipe_right_operator],\n00772|         [prec.left, PREC.colon, $._ellipsis_operator],\n00773|         [prec.left, PREC.plus, choice($._unary_plus_operator, $._plus_operator)],\n00774|         [prec.left, PREC.times, $._times_operator],\n00775|         [prec.left, PREC.rational, $._rational_operator],\n00776|         [prec.left, PREC.bitshift, $._bitshift_operator],\n00777|         [prec.left, PREC.power, $._power_operator],\n00778|       ];\n00779| \n00780|       return choice(...table.map(([fn, prec, op]) => fn(prec, seq(\n00781|         $._expression,\n00782|         alias(op, $.operator),\n00783|         $._expression,\n00784|       ))));\n00785|     },\n00786| \n00787|     unary_expression: $ => prec.right(PREC.prefix, seq(\n00788|       alias(choice(\n00789|         $._tilde_operator,\n00790|         $._type_order_operator,\n00791|         $._unary_operator,\n00792|         $._unary_plus_operator,\n00793|       ), $.operator),\n00794|       $._expression,\n00795|     )),\n00796| \n00797|     range_expression: $ => prec.left(PREC.colon, seq(\n00798|       $._expression,\n00799|       token.immediate(':'),\n00800|       $._expression,\n00801|     )),\n00802| \n00803|     splat_expression: $ => prec(PREC.colon, seq($._expression, '...')),\n00804| \n00805|     ternary_expression: $ => prec.right(PREC.conditional, seq(\n00806|       $._expression,\n00807|       '?',\n00808|       $._bracket_form,\n00809|       ':',\n00810|       $._bracket_form,\n00811|     )),\n00812| \n00813|     typed_expression: $ => prec(PREC.decl, seq(\n00814|       $._expression,\n00815|       '::',\n00816|       $._primary_expression,\n00817|     )),\n00818| \n00819|     unary_typed_expression: $ => prec.right(PREC.prefix, seq(\n00820|       '::',\n00821|       $._primary_expression,\n00822|     )),\n00823| \n00824|     arrow_function_expression: $ => prec.right(PREC.afunc, seq(\n00825|       choice(\n00826|         $.identifier,\n00827|         alias($.tuple_expression, $.argument_list),\n00828|         $.typed_expression,\n00829|       ),\n00830|       '->',\n00831|       $._bracket_form,\n00832|     )),\n00833| \n00834|     juxtaposition_expression: $ => prec.left(seq(\n00835|       choice(\n00836|         $.integer_literal,\n00837|         $.float_literal,\n00838|         $.adjoint_expression,\n00839|       ),\n00840|       $._primary_expression,\n00841|     )),\n00842| \n00843|     compound_assignment_expression: $ => prec.right(PREC.assign, seq(\n00844|       $._primary_expression,\n00845|       alias(choice($._assignment_operator, $._tilde_operator), $.operator),\n00846|       $._expression,\n00847|     )),\n00848| \n00849|     where_expression: $ => prec.left(PREC.where, seq(\n00850|       $._expression,\n00851|       'where',\n00852|       $._expression,\n00853|     )),\n00854| \n00855| \n00856|     // Tokens\n00857| \n00858|     macro_identifier: $ => seq('@', choice(\n00859|       $.identifier,\n00860|       $.operator,\n00861|       alias($._syntactic_operator, $.operator),\n00862|       alias($._scoped_identifier, $.field_expression),\n00863|     )),\n00864| \n00865|     _scoped_identifier: $ => seq(\n00866|       choice($.identifier, $.interpolation_expression),\n00867|       repeat1(\n00868|         seq(\n00869|           token.immediate('.'),\n00870|           choice($.identifier, $.interpolation_expression),\n00871|         ),\n00872|       ),\n00873|     ),\n00874| \n00875|     _word_identifier: _ => {\n00876|       const nonIdentifierCharacters = [\n00877|         '#',\n00878|         '$',\n00879|         ',',\n00880|         ':',\n00881|         ';',\n00882|         '@',\n00883|         '~',\n00884|         '(', ')',\n00885|         '{', '}',\n00886|         ...Object.values(OPERATORS),\n00887|       ].join(' ')\n00888|         .trim()\n00889|         .replace(/!/g, '')\n00890|         .replace(/-/g, '')\n00891|         .replace(/\\\\/g, '\\\\\\\\')\n00892|         .replace(/\\s+/g, '');\n00893| \n00894|       // Some symbols in Sm and So unicode categories that are identifiers\n00895|       const validMathSymbols = '°∀-∇∎-∑∫-∳';\n00896| \n00897|       const start = `[_\\\\p{XID_Start}${validMathSymbols}\\\\p{Emoji}&&[^0-9#*]]`;\n00898|       const rest = `[^\"'\\`\\\\s\\\\.\\\\-\\\\[\\\\]${nonIdentifierCharacters}]*`;\n00899|       return new RegExp(start + rest);\n00900|     },\n00901| \n00902|     identifier: $ => $._word_identifier,\n00903| \n00904|     // Literals\n00905| \n00906|     boolean_literal: _ => choice('true', 'false'),\n00907| \n00908|     integer_literal: _ => choice(\n00909|       token(seq('0b', numeral('01'))),\n00910|       token(seq('0o', numeral('0-7'))),\n00911|       token(seq('0x', numeral('0-9a-fA-F'))),\n00912|       numeral('0-9'),\n00913|     ),\n00914| \n00915|     float_literal: _ => {\n00916|       const dec = numeral('0-9');\n00917|       const hex = numeral('0-9a-fA-F');\n00918|       const exponent = /[eEf][+-]?\\d+/;\n00919|       const hex_exponent = /p[+-]?\\d+/;\n00920| \n00921|       const leading_period = token(seq(\n00922|         '.',\n00923|         dec,\n00924|         optional(exponent),\n00925|       ));\n00926| \n00927|       // This has to be split into two tokens to avoid conflicts with ellipsis\n00928|       const trailing_period = seq(\n00929|         dec,\n00930|         token.immediate(seq(\n00931|           '.',\n00932|           optional(dec),\n00933|           optional(exponent),\n00934|         )),\n00935|       );\n00936| \n00937|       const just_exponent = token(seq(dec, exponent));\n00938| \n00939|       const hex_float = token(seq(\n00940|         choice(\n00941|           seq('0x', hex, optional('.'), optional(hex)),\n00942|           seq('0x.', hex),\n00943|         ),\n00944|         hex_exponent,\n00945|       ));\n00946| \n00947|       return choice(leading_period, trailing_period, just_exponent, hex_float);\n00948|     },\n00949| \n00950|     _string: $ => choice(\n00951|       $.character_literal,\n00952|       $.string_literal,\n00953|       $.command_literal,\n00954|       $.prefixed_string_literal,\n00955|       $.prefixed_command_literal,\n00956|     ),\n00957| \n00958|     escape_sequence: _ => ESCAPE_SEQUENCE,\n00959| \n00960|     character_literal: _ => token(seq(\n00961|       '\\'',\n00962|       choice(\n00963|         /[^'\\\\]/,\n00964|         ESCAPE_SEQUENCE,\n00965|       ),\n00966|       '\\'',\n00967|     )),\n00968| \n00969|     _delimiter_str_1: _ => '\"',\n00970|     _delimiter_str_3: _ => '\"\"\"',\n00971|     _delimiter_cmd_1: _ => '`',\n00972|     _delimiter_cmd_3: _ => '```',\n00973| \n00974|     string_literal: $ => choice(\n00975|       seq(\n00976|         $._delimiter_str_1,\n00977|         repeat(choice(alias($._content_str_1, $.content), $.string_interpolation, $.escape_sequence)),\n00978|         $._end_str,\n00979|       ),\n00980|       seq(\n00981|         $._delimiter_str_3,\n00982|         repeat(choice(alias($._content_str_3, $.content), $.string_interpolation, $.escape_sequence)),\n00983|         $._end_str,\n00984|       ),\n00985|     ),\n00986| \n00987|     command_literal: $ => choice(\n00988|       seq(\n00989|         $._delimiter_cmd_1,\n00990|         repeat(choice(alias($._content_cmd_1, $.content), $.string_interpolation, $.escape_sequence)),\n00991|         $._end_cmd,\n00992|       ),\n00993|       seq(\n00994|         $._delimiter_cmd_3,\n00995|         repeat(choice(alias($._content_cmd_3, $.content), $.string_interpolation, $.escape_sequence)),\n00996|         $._end_cmd,\n00997|       ),\n00998|     ),\n00999| \n01000|     prefixed_string_literal: $ => prec.left(seq(\n01001|       field('prefix', $.identifier),\n01002|       $._immediate_string_start,\n01003|       choice(\n01004|         seq(\n01005|           $._delimiter_str_1,\n01006|           repeat(choice(alias($._content_str_1_raw, $.content), $.escape_sequence)),\n01007|           $._end_str,\n01008|         ),\n01009|         seq(\n01010|           $._delimiter_str_3,\n01011|           repeat(choice(alias($._content_str_3_raw, $.content), $.escape_sequence)),\n01012|           $._end_str,\n01013|         ),\n01014|       ),\n01015|       optional(field('suffix', $.identifier)),\n01016|     )),\n01017| \n01018|     prefixed_command_literal: $ => prec.left(seq(\n01019|       field('prefix', $.identifier),\n01020|       $._immediate_command_start,\n01021|       choice(\n01022|         seq(\n01023|           $._delimiter_cmd_1,\n01024|           repeat(choice(alias($._content_cmd_1_raw, $.content), $.escape_sequence)),\n01025|           $._end_cmd,\n01026|         ),\n01027|         seq(\n01028|           $._delimiter_cmd_3,\n01029|           repeat(choice(alias($._content_cmd_3_raw, $.content), $.escape_sequence)),\n01030|           $._end_cmd,\n01031|         ),\n01032|       ),\n01033|       optional(field('suffix', $.identifier)),\n01034|     )),\n01035| \n01036|     string_interpolation: $ => seq(\n01037|       '$',\n01038|       choice(\n01039|         $.identifier,\n01040|         seq($._immediate_paren, parenthesize($._bracket_form)),\n01041|       ),\n01042|     ),\n01043| \n01044|     operator: $ => choice(\n01045|       // NOTE: Syntactic operators (&&, +=, etc) cannot be used as identifiers.\n01046|       $._pair_operator,\n01047|       $._arrow_operator,\n01048|       $._comparison_operator,\n01049|       $._pipe_left_operator,\n01050|       $._pipe_right_operator,\n01051|       $._ellipsis_operator,\n01052|       ':',\n01053|       $._plus_operator,\n01054|       $._times_operator,\n01055|       $._rational_operator,\n01056|       $._bitshift_operator,\n01057|       $._power_operator,\n01058|       $._tilde_operator,\n01059|       $._type_order_operator,\n01060|       $._unary_operator,\n01061|       $._unary_plus_operator,\n01062|     ),\n01063| \n01064|     _assignment_operator: _ => choice(':=', '$=', '.=', addDot(OPERATORS.assignment)),\n01065| \n01066|     _pair_operator: _ => addDot('=>'),\n01067| \n01068|     _arrow_operator: _ => addDot(OPERATORS.arrow),\n01069| \n01070|     _lazy_or_operator: _ => addDot('||'),\n01071| \n01072|     _lazy_and_operator: _ => addDot('&&'),\n01073| \n01074|     _comparison_operator: _ => addDot(OPERATORS.comparison),\n01075| \n01076|     _pipe_right_operator: _ => addDot('|>'),\n01077| \n01078|     _pipe_left_operator: _ => addDot('<|'),\n01079| \n01080|     _ellipsis_operator: _ => token(choice('..', addDot(OPERATORS.ellipsis))),\n01081| \n01082|     _plus_operator: _ => addDot(OPERATORS.plus),\n01083| \n01084|     _times_operator: _ => addDot(OPERATORS.times),\n01085| \n01086|     _rational_operator: _ => addDot('//'),\n01087| \n01088|     _bitshift_operator: _ => addDot(OPERATORS.bitshift),\n01089| \n01090|     _power_operator: _ => addDot(OPERATORS.power),\n01091| \n01092| \n01093|     _tilde_operator: _ => addDot('~'), // unary or assignment\n01094| \n01095|     _type_order_operator: _ => addDot('<: >:'), // unary or comparison\n01096| \n01097|     _unary_operator: _ => addDot(OPERATORS.unary),\n01098| \n01099|     _unary_plus_operator: _ => addDot(OPERATORS.unary_plus),\n01100| \n01101| \n01102|     _syntactic_operator: _ => choice('$', '.', '...', '->', '?'),\n01103| \n01104| \n01105|     _semicolon: _ => seq(';', repeat(token.immediate(';'))),\n01106| \n01107|     _terminator: $ => choice(/\\r?\\n/, $._semicolon),\n01108| \n01109|     block_comment: $ => seq(/#=/, $._block_comment_rest),\n01110| \n01111|     // FIXME: This is currently a seq to avoid conflicts with block_comment\n01112|     line_comment: _ => seq(/#/, /.*/),\n01113|   },\n01114| });\n01115| \n01116| /**\n01117|  *\n01118|  * @param {RuleOrLiteral} separator\n01119|  * @param {RuleOrLiteral} rule\n01120|  */\n01121| function sep(separator, rule) {\n01122|   return optional(sep1(separator, rule));\n01123| }\n01124| \n01125| /**\n01126|  *\n01127|  * @param {RuleOrLiteral} separator\n01128|  * @param {RuleOrLiteral} rule\n01129|  */\n01130| function sep1(separator, rule) {\n01131|   return seq(rule, repeat(seq(separator, rule)));\n01132| }\n01133| \n01134| /**\n01135|  *\n01136|  * @param {string} operatorString\n01137|  */\n01138| function addDot(operatorString) {\n01139|   const operators = operatorString.trim().split(/\\s+/);\n01140|   return token(seq(optional('.'), operators.length > 1 ? choice(...operators) : operators[0]));\n01141| }\n01142| \n01143| /**\n01144|  * @param {string} range\n01145|  */\n01146| function numeral(range) {\n01147|   return RegExp(`[${range}]([${range}]|_[${range}])*`);\n01148| }\n01149| \n01150| /**\n01151|  *\n01152|  * @param {...any} rules\n01153|  */\n01154| function parenthesize(...rules) {\n01155|   return seq('(', ...rules, ')');\n01156| }\n01157| \n\n(End of file - total 1157 lines)\n</file>",
      "title": "internal/parser/grammars/julia/grammar.js",
      "metadata": {
        "preview": "/**\n * @file Julia grammar for tree-sitter\n * @author Max Brunsfeld <maxbrunsfeld@gmail.com>\n * @author Sergio A. Vargas <savargasqu+git@unal.edu.co>\n * @license MIT\n */\n\n/// <reference types=\"tree-sitter-cli/dsl\" />\n// @ts-check\n\nconst PREC = [\n  'afunc',\n  'pair',\n  'conditional',\n  'arrow',\n  'lazy_or',\n  'lazy_and',\n  'where', // FIXME\n  'comparison',\n  'pipe_left',",
        "truncated": false
      },
      "time": {
        "start": 1768657110379,
        "end": 1768657110389
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110390,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc573001kNTvxXrsgxEJGN",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "4r01WhfjA",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/internal/parser/grammars/clojure/grammar.js"
      },
      "output": "<file>\n00001| // one aim is to try to parse what is correct (in the sense of\n00002| // officially supported), but also be looser in parsing additional\n00003| // things.  this is more or less in line with advice from tree-sitter\n00004| // folks.\n00005| \n00006| function regex(...patts) {\n00007|   return RegExp(patts.join(\"\"));\n00008| }\n00009| \n00010| // java.lang.Character.isWhitespace AND comma\n00011| //\n00012| // Space Separator (Zs) but NOT including (U+00A0, U+2007, U+202F)\n00013| //   U+0020, U+1680, U+2000, U+2001, U+2002, U+2003, U+2004, U+2005,\n00014| //   U+2006, U+2008, U+2009, U+200A, U+205F, U+3000\n00015| // Line Separator (Zl)\n00016| //   U+2028\n00017| // Paragraph Separator (Zp)\n00018| //   U+2029\n00019| // Horizontal Tabulation\n00020| //   \\t\n00021| // Line Feed\n00022| //   \\n\n00023| // Vertical Tabulation\n00024| //   U+000B\n00025| // Form Feed\n00026| //   \\f\n00027| // Carriage Return\n00028| //   \\r\n00029| // File Separator\n00030| //   U+001C\n00031| // Group Separator\n00032| //   U+001D\n00033| // Record Separator\n00034| //   U+001E\n00035| // Unit Separator\n00036| //   U+001F\n00037| const WHITESPACE_CHAR =\n00038|       regex(\"[\",\n00039|             \"\\\\f\\\\n\\\\r\\\\t, \",\n00040|             \"\\\\u000B\\\\u001C\\\\u001D\\\\u001E\\\\u001F\",\n00041|             \"\\\\u2028\\\\u2029\\\\u1680\",\n00042|             \"\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2008\",\n00043|             \"\\\\u2009\\\\u200a\\\\u205f\\\\u3000\",\n00044|             \"]\");\n00045| \n00046| const WHITESPACE =\n00047|       token(repeat1(WHITESPACE_CHAR));\n00048| \n00049| const COMMENT =\n00050|       token(regex('(;|#!).*\\n?'));\n00051| \n00052| const DIGIT =\n00053|       regex('[0-9]');\n00054| \n00055| const ALPHANUMERIC =\n00056|       regex('[0-9a-zA-Z]');\n00057| \n00058| const HEX_DIGIT =\n00059|       regex('[0-9a-fA-F]');\n00060| \n00061| const OCTAL_DIGIT =\n00062|       regex('[0-7]');\n00063| \n00064| const HEX_NUMBER =\n00065|       seq(\"0\",\n00066|           regex('[xX]'),\n00067|           repeat1(HEX_DIGIT),\n00068|           optional(\"N\"));\n00069| \n00070| const OCTAL_NUMBER =\n00071|       seq(\"0\",\n00072|           repeat1(OCTAL_DIGIT),\n00073|           optional(\"N\"));\n00074| \n00075| // XXX: not constraining number before r/R\n00076| // XXX: not constraining portion after r/R\n00077| const RADIX_NUMBER =\n00078|       seq(repeat1(DIGIT),\n00079|           regex('[rR]'),\n00080|           repeat1(ALPHANUMERIC));\n00081| \n00082| const RATIO =\n00083|       seq(repeat1(DIGIT),\n00084|           \"/\",\n00085|           repeat1(DIGIT));\n00086| \n00087| const DOUBLE =\n00088|       seq(repeat1(DIGIT),\n00089|           optional(seq(\".\",\n00090|                        repeat(DIGIT))),\n00091|           optional(seq(regex('[eE]'),\n00092|                        optional(regex('[+-]')),\n00093|                        repeat1(DIGIT))),\n00094|           optional(\"M\"));\n00095| \n00096| const INTEGER =\n00097|       seq(repeat1(DIGIT),\n00098|           optional(regex('[MN]')));\n00099| \n00100| const NUMBER =\n00101|       token(prec(10, seq(optional(regex('[+-]')),\n00102|                          choice(HEX_NUMBER,\n00103|                                 OCTAL_NUMBER,\n00104|                                 RADIX_NUMBER,\n00105|                                 RATIO,\n00106|                                 DOUBLE,\n00107|                                 INTEGER))));\n00108| \n00109| const NIL =\n00110|       token('nil');\n00111| \n00112| const BOOLEAN =\n00113|       token(choice('false',\n00114|                    'true'));\n00115| \n00116| const KEYWORD_HEAD =\n00117|       regex(\"[^\",\n00118|             \"\\\\f\\\\n\\\\r\\\\t \",\n00119|             \"()\",\n00120|             \"\\\\[\\\\]\",\n00121|             \"{}\",\n00122|             '\"',\n00123|             \"@~^;`\",\n00124|             \"\\\\\\\\\",\n00125|             \",:/\",\n00126|             \"\\\\u000B\\\\u001C\\\\u001D\\\\u001E\\\\u001F\",\n00127|             \"\\\\u2028\\\\u2029\\\\u1680\",\n00128|             \"\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2008\",\n00129|             \"\\\\u2009\\\\u200a\\\\u205f\\\\u3000\",\n00130|             \"]\");\n00131| \n00132| const KEYWORD_BODY =\n00133|       choice(regex(\"[:']\"), KEYWORD_HEAD);\n00134| \n00135| const KEYWORD_NAMESPACED_BODY =\n00136|       token(repeat1(choice(regex(\"[:'/]\"), KEYWORD_HEAD)));\n00137| \n00138| const KEYWORD_NO_SIGIL =\n00139|       token(seq(KEYWORD_HEAD,\n00140|                 repeat(KEYWORD_BODY)));\n00141| \n00142| const KEYWORD_MARK =\n00143|       token(\":\");\n00144| \n00145| const AUTO_RESOLVE_MARK =\n00146|       token(\"::\");\n00147| \n00148| const STRING =\n00149|       token(seq('\"',\n00150|                 repeat(regex('[^\"\\\\\\\\]')),\n00151|                 repeat(seq(\"\\\\\",\n00152|                            regex(\".\"),\n00153|                            repeat(regex('[^\"\\\\\\\\]')))),\n00154|                 '\"'));\n00155| \n00156| // XXX: better to match \\o378 as a single item\n00157| const OCTAL_CHAR =\n00158|       seq(\"o\",\n00159|           choice(seq(DIGIT, DIGIT, DIGIT),\n00160|                  seq(DIGIT, DIGIT),\n00161|                  seq(DIGIT)));\n00162| \n00163| const NAMED_CHAR =\n00164|       choice(\"backspace\",\n00165|              \"formfeed\",\n00166|              \"newline\",\n00167|              \"return\",\n00168|              \"space\",\n00169|              \"tab\");\n00170| \n00171| // XXX: outside of: (c >= '\\uD800' && c <= '\\uDFFF') - LispReader.java\n00172| //      but not doing this\n00173| const UNICODE =\n00174|       seq(\"u\",\n00175|           HEX_DIGIT,\n00176|           HEX_DIGIT,\n00177|           HEX_DIGIT,\n00178|           HEX_DIGIT);\n00179| \n00180| // XXX: not quite sure what this is supposed to be...\n00181| //      return Character.valueOf(token.charAt(0)); -- LispReader.java\n00182| //      java char is 16 bits...what can tree-sitter manage?\n00183| //\n00184| // XXX: null is supposed to be usable but putting \\x00 below\n00185| //      does not seem to work\n00186| const ANY_CHAR =\n00187|       regex('.|\\n');\n00188| \n00189| const CHARACTER =\n00190|       token(seq(\"\\\\\",\n00191|                 choice(OCTAL_CHAR,\n00192|                        NAMED_CHAR,\n00193|                        UNICODE,\n00194|                        ANY_CHAR)));\n00195| \n00196| const SYMBOL_HEAD =\n00197|       regex(\"[^\",\n00198|             \"\\\\f\\\\n\\\\r\\\\t \",\n00199|             \"/\",\n00200|             \"()\\\\[\\\\]{}\",\n00201|             '\"',\n00202|             \"@~^;`\",\n00203|             \"\\\\\\\\\",\n00204|             \",:#'0-9\",\n00205|             \"\\\\u000B\\\\u001C\\\\u001D\\\\u001E\\\\u001F\",\n00206|             \"\\\\u2028\\\\u2029\\\\u1680\",\n00207|             \"\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2008\",\n00208|             \"\\\\u2009\\\\u200a\\\\u205f\\\\u3000\",\n00209|             \"]\");\n00210| \n00211| const NS_DELIMITER =\n00212|       token(\"/\");\n00213| \n00214| const SYMBOL_BODY =\n00215|       choice(SYMBOL_HEAD,\n00216|              regex(\"[:#'0-9]\"));\n00217| \n00218| const SYMBOL_NAMESPACED_NAME =\n00219|       token(repeat1(choice(SYMBOL_HEAD,\n00220|                            regex(\"[/:#'0-9]\"))));\n00221| \n00222| // XXX: no attempt is made to enforce certain complex things, e.g.\n00223| //\n00224| //        Symbols beginning or ending with ':' are reserved by Clojure.\n00225| //        A symbol can contain one or more non-repeating ':'s\n00226| const SYMBOL =\n00227|       token(seq(SYMBOL_HEAD,\n00228|                 repeat(SYMBOL_BODY)));\n00229| \n00230| module.exports = grammar({\n00231|   name: 'clojure',\n00232| \n00233|   extras: $ =>\n00234|   [],\n00235| \n00236|   conflicts: $ =>\n00237|   [],\n00238| \n00239|   inline: $ =>\n00240|   [$._kwd_leading_slash,\n00241|    $._kwd_just_slash,\n00242|    $._kwd_qualified,\n00243|    $._kwd_unqualified,\n00244|    $._kwd_marker,\n00245|    $._sym_qualified,\n00246|    $._sym_unqualified],\n00247| \n00248|   rules: {\n00249|     // THIS MUST BE FIRST -- even though this doesn't look like it matters\n00250|     source: $ =>\n00251|     repeat(choice($._form,\n00252|                   $._gap)),\n00253| \n00254|     _gap: $ =>\n00255|     choice($._ws,\n00256|            $.comment,\n00257|            $.dis_expr),\n00258| \n00259|     _ws: $ =>\n00260|     WHITESPACE,\n00261| \n00262|     comment: $ =>\n00263|     COMMENT,\n00264| \n00265|     dis_expr: $ =>\n00266|     seq(field('marker', \"#_\"),\n00267|         repeat($._gap),\n00268|         field('value', $._form)),\n00269| \n00270|     _form: $ =>\n00271|     choice($.num_lit, // atom-ish\n00272|            $.kwd_lit,\n00273|            $.str_lit,\n00274|            $.char_lit,\n00275|            $.nil_lit,\n00276|            $.bool_lit,\n00277|            $.sym_lit,\n00278|            // basic collection-ish\n00279|            $.list_lit,\n00280|            $.map_lit,\n00281|            $.vec_lit,\n00282|            // dispatch reader macros\n00283|            $.set_lit,\n00284|            $.anon_fn_lit,\n00285|            $.regex_lit,\n00286|            $.read_cond_lit,\n00287|            $.splicing_read_cond_lit,\n00288|            $.ns_map_lit,\n00289|            $.var_quoting_lit,\n00290|            $.sym_val_lit,\n00291|            $.evaling_lit,\n00292|            $.tagged_or_ctor_lit,\n00293|            // some other reader macros\n00294|            $.derefing_lit,\n00295|            $.quoting_lit,\n00296|            $.syn_quoting_lit,\n00297|            $.unquote_splicing_lit,\n00298|            $.unquoting_lit),\n00299| \n00300|     num_lit: $ =>\n00301|     NUMBER,\n00302| \n00303|     kwd_lit: $ =>\n00304|     choice($._kwd_leading_slash,\n00305|            $._kwd_just_slash,\n00306|            $._kwd_qualified,\n00307|            $._kwd_unqualified),\n00308| \n00309|     // (namespace :/usr/bin/env) ; => \"\"\n00310|     // (name :/usr/bin/env) ; => \"usr/bin/env\"\n00311|     _kwd_leading_slash: $ =>\n00312|     seq(field('marker', $._kwd_marker),\n00313|         field('delimiter', NS_DELIMITER),\n00314|         field('name', alias(KEYWORD_NAMESPACED_BODY, $.kwd_name))),\n00315| \n00316|     // (namespace :/) ;=> nil\n00317|     // (name :/) ;=> \"/\"\n00318|     _kwd_just_slash: $ =>\n00319|     seq(field('marker', $._kwd_marker),\n00320|         field('name', alias(NS_DELIMITER, $.kwd_name))),\n00321| \n00322|     _kwd_qualified: $ =>\n00323|     prec(2, seq(field('marker', $._kwd_marker),\n00324|                 field('namespace', alias(KEYWORD_NO_SIGIL, $.kwd_ns)),\n00325|                 field('delimiter', NS_DELIMITER),\n00326|                 field('name', alias(KEYWORD_NAMESPACED_BODY, $.kwd_name)))),\n00327| \n00328|     _kwd_unqualified: $ =>\n00329|     prec(1, seq(field('marker', $._kwd_marker),\n00330|                 field('name', alias(KEYWORD_NO_SIGIL, $.kwd_name)))),\n00331| \n00332|     _kwd_marker: $ =>\n00333|     choice(KEYWORD_MARK, AUTO_RESOLVE_MARK),\n00334| \n00335|     str_lit: $ =>\n00336|     STRING,\n00337| \n00338|     char_lit: $ =>\n00339|     CHARACTER,\n00340| \n00341|     nil_lit: $ =>\n00342|     NIL,\n00343| \n00344|     bool_lit: $ =>\n00345|     BOOLEAN,\n00346| \n00347|     sym_lit: $ =>\n00348|     seq(repeat($._metadata_lit),\n00349|         choice($._sym_qualified, $._sym_unqualified)),\n00350| \n00351|     _sym_qualified: $ =>\n00352|     prec(1, seq(field(\"namespace\", alias(SYMBOL, $.sym_ns)),\n00353|                 field(\"delimiter\", NS_DELIMITER),\n00354|                 field(\"name\", alias(SYMBOL_NAMESPACED_NAME, $.sym_name)))),\n00355| \n00356|     _sym_unqualified: $ =>\n00357|     field('name', alias(choice(NS_DELIMITER, // division symbol\n00358|                                SYMBOL),\n00359|                         $.sym_name)),\n00360| \n00361|     _metadata_lit: $ =>\n00362|     seq(choice(field(\"meta\", $.meta_lit),\n00363|                field(\"old_meta\", $.old_meta_lit)),\n00364|         optional(repeat($._gap))),\n00365| \n00366|     meta_lit: $ =>\n00367|     seq(field('marker', \"^\"),\n00368|         repeat($._gap),\n00369|         field('value', $._form)),\n00370| \n00371|     old_meta_lit: $ =>\n00372|     seq(field('marker', \"#^\"),\n00373|         repeat($._gap),\n00374|         field('value', $._form)),\n00375| \n00376|     list_lit: $ =>\n00377|     seq(repeat($._metadata_lit),\n00378|         $._bare_list_lit),\n00379| \n00380|     _bare_list_lit: $ =>\n00381|     seq(field('open', \"(\"),\n00382|         repeat(choice(field('value', $._form),\n00383|                       $._gap)),\n00384|         field('close', \")\")),\n00385| \n00386|     map_lit: $ =>\n00387|     seq(repeat($._metadata_lit),\n00388|         $._bare_map_lit),\n00389| \n00390|     _bare_map_lit: $ =>\n00391|     seq(field('open', \"{\"),\n00392|         repeat(choice(field('value', $._form),\n00393|                       $._gap)),\n00394|         field('close', \"}\")),\n00395| \n00396|     vec_lit: $ =>\n00397|     seq(repeat($._metadata_lit),\n00398|         $._bare_vec_lit),\n00399| \n00400|     _bare_vec_lit: $ =>\n00401|     seq(field('open', \"[\"),\n00402|         repeat(choice(field('value', $._form),\n00403|                       $._gap)),\n00404|         field('close', \"]\")),\n00405| \n00406|     set_lit: $ =>\n00407|     seq(repeat($._metadata_lit),\n00408|         $._bare_set_lit),\n00409| \n00410|     _bare_set_lit: $ =>\n00411|     seq(field('marker', \"#\"),\n00412|         field('open', \"{\"),\n00413|         repeat(choice(field('value', $._form),\n00414|                       $._gap)),\n00415|         field('close', \"}\")),\n00416| \n00417|     anon_fn_lit: $ =>\n00418|     seq(repeat($._metadata_lit),\n00419|         field('marker', \"#\"),\n00420|         $._bare_list_lit),\n00421| \n00422|     regex_lit: $ =>\n00423|     seq(field('marker', \"#\"),\n00424|         STRING),\n00425| \n00426|     read_cond_lit: $ =>\n00427|     seq(repeat($._metadata_lit),\n00428|         field('marker', \"#?\"),\n00429|         // whitespace possible, but neither comment nor discard\n00430|         repeat($._ws),\n00431|         $._bare_list_lit),\n00432| \n00433|     splicing_read_cond_lit: $ =>\n00434|     // XXX: metadata here doesn't seem to make sense, but the repl\n00435|     //      will accept: [^:x #?@(:clj [[:a]] :cljr [[:b]])]\n00436|     seq(repeat($._metadata_lit),\n00437|         field('marker', \"#?@\"),\n00438|         // whitespace possible, but neither comment nor discard\n00439|         repeat($._ws),\n00440|         $._bare_list_lit),\n00441| \n00442|     auto_res_mark: $ =>\n00443|     AUTO_RESOLVE_MARK,\n00444| \n00445|     ns_map_lit: $ =>\n00446|     seq(repeat($._metadata_lit),\n00447|         field('marker', \"#\"),\n00448|         field('prefix', choice($.auto_res_mark,\n00449|                                $.kwd_lit)),\n00450|         repeat($._gap),\n00451|         $._bare_map_lit),\n00452| \n00453|     var_quoting_lit: $ =>\n00454|     seq(repeat($._metadata_lit),\n00455|         field('marker', \"#'\"),\n00456|         repeat($._gap),\n00457|         // XXX: symbol, reader conditional, and tagged literal can work\n00458|         //      any other things?\n00459|         field('value', $._form)),\n00460| \n00461|     sym_val_lit: $ =>\n00462|     seq(field('marker', \"##\"),\n00463|         repeat($._gap),\n00464|         field('value', $._form)),\n00465| \n00466|     evaling_lit: $ =>\n00467|     seq(repeat($._metadata_lit), // ^:x #=(vector 1)\n00468|         field('marker', \"#=\"),\n00469|         repeat($._gap),\n00470|         field('value', choice($.list_lit,\n00471|                               $.read_cond_lit,\n00472|                               // #= ^:a java.lang.String\n00473|                               $.sym_lit))),\n00474| \n00475|     // #uuid \"00000000-0000-0000-0000-000000000000\"\n00476|     // #user.Fun[1 2]\n00477|     // #user.Fun{:a 1 :b 2}\n00478|     tagged_or_ctor_lit: $ =>\n00479|     seq(repeat($._metadata_lit),\n00480|         field('marker', \"#\"),\n00481|         // # uuid \"00000000-0000-0000-0000-000000000000\"\n00482|         // # #_ 1 uuid \"00000000-0000-0000-0000-000000000000\"\n00483|         // etc.\n00484|         repeat($._gap),\n00485|         // # ^:a uuid \"00000000-0000-0000-0000-000000000000\"\n00486|         field('tag', $.sym_lit),\n00487|         repeat($._gap),\n00488|         field('value', $._form)),\n00489| \n00490|     derefing_lit: $ =>\n00491|     seq(repeat($._metadata_lit),\n00492|         field('marker', \"@\"),\n00493|         repeat($._gap),\n00494|         field('value', $._form)),\n00495| \n00496|     quoting_lit: $ =>\n00497|     seq(repeat($._metadata_lit),\n00498|         field('marker', \"'\"),\n00499|         repeat($._gap),\n00500|         field('value', $._form)),\n00501| \n00502|     syn_quoting_lit: $ =>\n00503|     seq(repeat($._metadata_lit),\n00504|         field('marker', \"`\"),\n00505|         repeat($._gap),\n00506|         field('value', $._form)),\n00507| \n00508|     unquote_splicing_lit: $ =>\n00509|     // XXX: metadata here doesn't seem to make sense, but the repl\n00510|     //      will accept: `(^:x ~@[:a :b :c])\n00511|     seq(repeat($._metadata_lit),\n00512|         field('marker', \"~@\"),\n00513|         repeat($._gap),\n00514|         field('value', $._form)),\n00515| \n00516|     unquoting_lit: $ =>\n00517|     seq(repeat($._metadata_lit),\n00518|         field('marker', \"~\"),\n00519|         repeat($._gap),\n00520|         field('value', $._form)),\n00521|   }\n00522| });\n00523| \n00524| // Local Variables:\n00525| // mode: js-mode\n00526| // js-indent-align-list-continuation: t\n00527| // js-indent-level: 2\n00528| // End:\n00529| \n\n(End of file - total 529 lines)\n</file>",
      "title": "internal/parser/grammars/clojure/grammar.js",
      "metadata": {
        "preview": "// one aim is to try to parse what is correct (in the sense of\n// officially supported), but also be looser in parsing additional\n// things.  this is more or less in line with advice from tree-sitter\n// folks.\n\nfunction regex(...patts) {\n  return RegExp(patts.join(\"\"));\n}\n\n// java.lang.Character.isWhitespace AND comma\n//\n// Space Separator (Zs) but NOT including (U+00A0, U+2007, U+202F)\n//   U+0020, U+1680, U+2000, U+2001, U+2002, U+2003, U+2004, U+2005,\n//   U+2006, U+2008, U+2009, U+200A, U+205F, U+3000\n// Line Separator (Zl)\n//   U+2028\n// Paragraph Separator (Zp)\n//   U+2029\n// Horizontal Tabulation\n//   \\t",
        "truncated": false
      },
      "time": {
        "start": 1768657110388,
        "end": 1768657110390
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110391,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc570001yFCxGB1x3cQI1f",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "fcglxpwHG",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/internal/parser/grammars/commonlisp/queries/tags.scm"
      },
      "output": "<file>\n00001| ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n00002| ;;; Function Definitions ;;;;;;;;;;;;;;;;;;;;;;;\n00003| \n00004| (defun_header\n00005|   function_name: (sym_lit) @name) @definition.function\n00006| \n00007| ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n00008| ;;; Function Calls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n00009| ;;;\n00010| ;;; Basically, we consider every list literal with symbol as the\n00011| ;;; first element to be a call to a function named by that element.\n00012| ;;; But we must exclude some cases. Note, tree-sitter @ignore\n00013| ;;; cases only work if they are declared before the cases\n00014| ;;; we want to include.\n00015| \n00016| ;; Exclude lambda lists for function definitions\n00017| ;; For example:\n00018| ;;\n00019| ;;    (defun my-func (arg1 arg2) ...)\n00020| ;;\n00021| ;; do not treat (arg1 arg2) as a call of function arg1\n00022| ;;\n00023| (defun_header\n00024|   lambda_list: (list_lit . [(sym_lit) (package_lit)] @ignore))\n00025| \n00026| ;; Similar to the above, but for\n00027| ;;\n00028| ;;     (defmethod m ((type1 param1) (type2 param2)) ...)\n00029| ;;\n00030| ;; where list literals having symbol as their first element\n00031| ;; are nested inside the lambda list.\n00032| (defun_header\n00033|   lambda_list: (list_lit (list_lit . [(sym_lit) (package_lit)] @ignore)))\n00034| \n00035| ;;\n00036| ;;      (let ((var ...) (var2 ...)) ...)\n00037| ;;\n00038| ;; - exclude var, var2\n00039| ;; - the same for let*, flet, labels, macrolet, symbol-macrolet\n00040| (list_lit . [(sym_lit) (package_lit)] @name\n00041|           . (list_lit (list_lit . [(sym_lit) (package_lit)] @ignore))\n00042|           (#match? @name\n00043|                    \"(?i)^(cl:)?(let|let\\\\*|flet|labels|macrolet|symbol-macrolet)$\")\n00044|   )\n00045| \n00046| ;; TODO:\n00047| ;;     - exclude also:\n00048| ;;       - (defclass name (parent parent2)\n00049| ;;           ((slot1 ...)\n00050| ;;            (slot2 ...))\n00051| ;;              exclude the parent, slot1, slot2\n00052| ;;       - (flet ((func-1 (param1 param2))) ...)\n00053| ;;           - we already exclude func-1, but param1 is still recognized\n00054| ;;             as a function call - exclude it too\n00055| ;;           - the same for labels\n00056| ;;           - the same macrolet\n00057| ;;       - what else?\n00058| ;;         (that's a non-goal to completely support all macros\n00059| ;;          and special operators, but every one we support\n00060| ;;          makes the solution a little bit better)\n00061| ;;     - (flet ((func-1 (param1 param2))) ...)\n00062| ;;       - instead of simply excluding it, as we do today,\n00063| ;;         tag func-1 as @local.definition.function (I suppose)\n00064| ;;       - the same for labels, macrolet\n00065| ;;     - @local.scope for let, let*, flet, labels, macrolet\n00066| ;;       - I guess the whole span of the scope text,\n00067| ;;         till the closing paren, should be tagged as @local.scope;\n00068| ;;         Hopefully, combined with @local.definition.function\n00069| ;;         withing the scope, the usual  @reference.call within\n00070| ;;         that scope will refer to the local definition,\n00071| ;;         and there will be no need to use @local.reference.call\n00072| ;;         (which is more difficult to implement).\n00073| ;;       - When implementing, remeber the scope rules differences\n00074| ;;         of let vs let*, flet vs labels.\n00075| \n00076| \n00077| ;; Inlclude all other cases - list literal with symbol as the\n00078| ;; first element\n00079| (list_lit . [(sym_lit) (package_lit)] @name) @reference.call\n00080| \n00081| ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n00082| ;;; classes\n00083| \n00084| (list_lit . [(sym_lit) (package_lit)] @ignore\n00085|           . [(sym_lit) (package_lit)] @name\n00086|   (#match? @ignore \"(?i)^(cl:)?defclass$\")\n00087|           ) @definition.class\n00088| \n00089| (list_lit . [(sym_lit) (package_lit)] @ignore\n00090|           . (quoting_lit [(sym_lit) (package_lit)] @name)\n00091|   (#match? @ignore \"(?i)^(cl:)?make-instance$\")\n00092|           ) @reference.class\n00093| \n00094| ;;; TODO:\n00095| ;;  - @reference.class for base classes\n00096| \n00097| ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n00098| ;;; TODO:\n00099| ;; - Symbols referenced in defpackage\n00100| ;;\n00101| ;;       (defpackage ...\n00102| ;;         (:export (symbol-a :symbol-b #:symbol-c \"SYMBOL-D\")))\n00103| ;;\n00104| ;;   The goal is to allow quick navigation from the API\n00105| ;;   overview in the form of defpackage, to the definition\n00106| ;;   where user can read parameters, docstring, ect.\n00107| ;;   - The @name must not include the colon, or sharpsign colon, quotes,\n00108| ;;     just symbol-a, symbol-b, symbol-c, sybmol-d\n00109| ;;   - Downcase the names specified as stirng literals?\n00110| ;;     (\"SYMBOL-D\" -> symbol-d)\n00111| ;;   - We don't know if the exported symbol is a function, variable,\n00112| ;;     class or something else. The oficial doc\n00113| ;;     (https://tree-sitter.github.io/tree-sitter/code-navigation-systems)\n00114| ;;     does not even suggest a tag for variable reference.\n00115| ;;     (Although in practice, the `tree-sitter tags` command\n00116| ;;     allows any @reference.* and @definition.* tags)\n00117| ;;     Probably it's better to just use @reference.call for all\n00118| ;;     the symbols in the :export clause.\n00119| ;;\n00120| ;; - The same for the export function call:\n00121| ;; \n00122| ;;       (export '(symbol-a :symbol-b #:symbol-c \"SYMBOL-D\"))\n00123| \n\n(End of file - total 123 lines)\n</file>",
      "title": "internal/parser/grammars/commonlisp/queries/tags.scm",
      "metadata": {
        "preview": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Function Definitions ;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun_header\n  function_name: (sym_lit) @name) @definition.function\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Function Calls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\n;;; Basically, we consider every list literal with symbol as the\n;;; first element to be a call to a function named by that element.\n;;; But we must exclude some cases. Note, tree-sitter @ignore\n;;; cases only work if they are declared before the cases\n;;; we want to include.\n\n;; Exclude lambda lists for function definitions\n;; For example:\n;;\n;;    (defun my-func (arg1 arg2) ...)\n;;",
        "truncated": false
      },
      "time": {
        "start": 1768657110385,
        "end": 1768657110390
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110391,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc572001b56ANDy1R1OkiF",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "Q8ZaBruqB",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/internal/parser/grammars/commonlisp/grammar.js"
      },
      "output": "<file>\n00001| /*\n00002|  * grammar.js\n00003|  * Copyright (C) 2021 Stephan Seitz <stephan.seitz@fau.de>\n00004|  * Adapted from tree-sitter-clojure\n00005|  *\n00006|  * Distributed under terms of the MIT license.\n00007|  */\n00008| \n00009| const clojure = require(\"tree-sitter-clojure/grammar\");\n00010| \n00011| const WHITESPACE_CHAR =\n00012|     /[\\f\\n\\r\\t \\u000B\\u001C\\u001D\\u001E\\u001F\\u2028\\u2029\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2008\\u2009\\u200a\\u205f\\u3000]/;\n00013| \n00014| const WHITESPACE =\n00015|     token(repeat1(WHITESPACE_CHAR));\n00016| \n00017| const PREC = {\n00018|     NUM_LIT: 0,\n00019|     NORMAL: 1,\n00020|     PACKAGE_LIT: 2,\n00021|     DOTTET_LIT: 3,\n00022|     KWD_LIT: 4,\n00023|     SPECIAL: 5,\n00024|     META_LIT: 6,\n00025| }\n00026| \n00027| const SYMBOL_HEAD =\n00028|     /[^:\\f\\n\\r\\t ()\\[\\]{}\"^;`\\\\,#'\\u000B\\u001C\\u001D\\u001E\\u001F\\u2028\\u2029\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2008\\u2009\\u200a\\u205f\\u3000]/;\n00029| \n00030| const SYMBOL_WITHOUT_SLASH =\n00031|     /[^:\\f\\n\\r\\t ()\\[\\]{}\"^;/`\\\\,#'\\u000B\\u001C\\u001D\\u001E\\u001F\\u2028\\u2029\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2008\\u2009\\u200a\\u205f\\u3000]/;\n00032| \n00033| const SYMBOL_BODY =\n00034|     choice(SYMBOL_HEAD,\n00035|         /[#']/);\n00036| \n00037| const SYMBOL =\n00038|     token(seq(SYMBOL_HEAD,\n00039|         repeat(SYMBOL_BODY)));\n00040| \n00041| const STRING =\n00042|     token(seq('\"',\n00043|         repeat(/[^\"\\\\]/),\n00044|         repeat(seq(\"\\\\\",\n00045|             /./,\n00046|             repeat(/[^\"\\\\]/))),\n00047|         '\"'));\n00048| \n00049| const DIGIT =\n00050|     /[0-9]/;\n00051| \n00052| const ALPHANUMERIC =\n00053|     /[0-9a-zA-Z]/;\n00054| \n00055| const HEX_DIGIT =\n00056|     /[0-9a-fA-F]/;\n00057| \n00058| const OCTAL_DIGIT =\n00059|     /[0-7]/;\n00060| \n00061| const BINARY_DIGIT =\n00062|     /[0-1]/;\n00063| \n00064| const HEX_NUMBER =\n00065|     seq(choice('#x', '#X'), optional(/[+-]/),\n00066|         repeat1(HEX_DIGIT));\n00067| \n00068| const OCTAL_NUMBER =\n00069|     seq(choice('#o', '#O'), optional(/[+-]/),\n00070|         repeat1(OCTAL_DIGIT));\n00071| \n00072| const BINARY_NUMBER =\n00073|     seq(choice('#b', '#B'), optional(/[+-]/),\n00074|         repeat1(BINARY_DIGIT));\n00075| \n00076| const RADIX_NUMBER =\n00077|     seq('#',\n00078|         repeat1(DIGIT),\n00079|         /[rR]/,\n00080|         repeat1(ALPHANUMERIC));\n00081| \n00082| // XXX: not accounting for division by zero\n00083| const RATIO =\n00084|     seq(repeat1(DIGIT),\n00085|         \"/\",\n00086|         repeat1(DIGIT));\n00087| \n00088| const DOUBLE =\n00089|     seq(repeat1(DIGIT),\n00090|         optional(seq(\".\",\n00091|             repeat(DIGIT))),\n00092|         optional(seq(/[eEsSfFdDlL]/,\n00093|             optional(/[+-]/),\n00094|             repeat1(DIGIT))),\n00095|     );\n00096| \n00097| const INTEGER =\n00098|     seq(repeat1(DIGIT),\n00099|         optional(/[MN]/));\n00100| \n00101| const NUMBER =\n00102|     token(seq(optional(/[+-]/),\n00103|         choice(\n00104|             HEX_NUMBER,\n00105|             OCTAL_NUMBER,\n00106|             RADIX_NUMBER,\n00107|             BINARY_NUMBER,\n00108|             RATIO,\n00109|             DOUBLE,\n00110|             INTEGER)));\n00111| \n00112| \n00113| function clSymbol(symbol) {\n00114|     return seq(optional(seq('cl', ':')), symbol)\n00115| }\n00116| \n00117| function loopSymbol(symbol) {\n00118|     return seq(optional(seq(optional('cl'), ':')), symbol)\n00119| }\n00120| \n00121| function optSeq(...args) {\n00122|     return optional(seq(...args))\n00123| }\n00124| \n00125| \n00126| module.exports = grammar(clojure, {\n00127|     name: 'commonlisp',\n00128| \n00129|     extras: ($, original) => [...original, $.block_comment],\n00130|     conflicts: ($,\n00131|         original) => [...original,\n00132|         [$.for_clause_word, $.package_lit],\n00133|         [$.with_clause, $.package_lit],\n00134|         [$.with_clause],\n00135|         [$.for_clause],\n00136|         [$.accumulation_clause]],\n00137| \n00138| \n00139|     rules: {\n00140|         block_comment: _ => token(seq('#|', repeat(choice(/[^|]/, /\\|[^#]/)), '|#')),\n00141| \n00142|         fancy_literal: _ => token(seq('|', repeat(/[^|]/), '|')),\n00143| \n00144|         _ws: _ =>\n00145|             WHITESPACE,\n00146| \n00147|         unquoting_lit: $ =>\n00148|             seq(field('marker', \",\"),\n00149|                 repeat($._gap),\n00150|                 field('value', $._form)),\n00151| \n00152|         unquote_splicing_lit: $ =>\n00153|             seq(repeat($._metadata_lit),\n00154|                 field('marker', \",@\"),\n00155|                 repeat($._gap),\n00156|                 field('value', $._form)),\n00157| \n00158|         syn_quoting_lit: $ =>\n00159|             seq(field('marker', \"`\"),\n00160|                 repeat($._gap),\n00161|                 field('value', ($._form))),\n00162| \n00163|         defun: $ =>\n00164|             prec(PREC.SPECIAL, seq(field('open', \"(\"),\n00165|                 optional($._gap),\n00166|                 $.defun_header,\n00167|                 optional($._gap),\n00168|                 repeat(choice(field('value', $._form), $._gap)),\n00169|                 field('close', \")\"))),\n00170| \n00171|         _format_token: $ => choice(alias(NUMBER, $.num_lit), seq(\"'\", alias(/./, $.char_lit))),\n00172|         // https://en.wikipedia.org/wiki/Format_Common_Lisp)\n00173|         format_prefix_parameters: _ => choice('v', 'V', '#'),\n00174|         format_modifiers: $ => seq(repeat(choice($._format_token, ',')), choice('@', '@:', ':', ':@')),\n00175|         //format_modifiers: _ => choice('@', '@:', ':', ':@'),\n00176|         format_directive_type: $ => choice(\n00177|             seq(optional(field('repetitions', $._format_token)), choice('~', '%', '&', '|')),\n00178|             /[cC]/,\n00179|             /\\^/,\n00180|             '\\n',\n00181|             '\\r',\n00182|             /[pP]/,\n00183|             /[iI]/,\n00184|             /[wW]/,\n00185|             /[aA]/,\n00186|             '_',\n00187|             /[()]/,\n00188|             /[{}]/,\n00189|             /[\\[\\]]/,\n00190|             /[<>]/,\n00191|             ';',\n00192|             seq(field('numberOfArgs', $._format_token), '*'),\n00193|             seq('/', choice(alias($._package_lit_without_slash, $.package_lit), $._sym_lit_without_slash), '/'),\n00194|             '?',\n00195|             \"Newline\",\n00196|             seq(repeat(choice($._format_token, ',')), /[$rRbBdDgGxXeEoOsStTfF]/),\n00197|         ),\n00198|         format_specifier: $ =>\n00199|             prec.left(seq(\n00200|                 '~',\n00201|                 optional($.format_prefix_parameters),\n00202|                 optional($.format_modifiers),\n00203|                 prec(5, $.format_directive_type),\n00204|             )),\n00205| \n00206|         str_lit: $ =>\n00207|             seq(\n00208|                 '\"',\n00209|                 repeat(choice(\n00210|                     token.immediate(prec(1, /[^\\\\~\"]+/)),\n00211|                     token.immediate(seq(/\\\\./)),\n00212|                     $.format_specifier,\n00213|                 )),\n00214|                 optional('~'),\n00215|                 '\"',\n00216|             ),\n00217| \n00218|         for_clause_word: _ => loopSymbol(choice(\n00219|             'in',\n00220|             'across',\n00221|             'being',\n00222|             'using',\n00223|             /being (the|each) (hash-key[s]?|hash-value[s]?|present-symbol[s]?) (in|of)/,\n00224|             'below',\n00225|             'above',\n00226|             'from',\n00227|             'to',\n00228|             'upto',\n00229|             'upfrom',\n00230|             'downto',\n00231|             'downfrom',\n00232|             'on',\n00233|             'by',\n00234|             'then',\n00235|             '=')),\n00236| \n00237| \n00238|         _for_part: $ => seq(repeat($._gap), $.for_clause_word, repeat($._gap), $._form),\n00239| \n00240|         accumulation_verb: _ => loopSymbol(/(maximize|minimize|(collect|append|nconc|count)(ing)?|sum(ming)?|maximizing|minimizing)/),\n00241|         for_clause: $ => choice(seq(choice(loopSymbol('for'), loopSymbol('and'), loopSymbol('as')), repeat($._gap), field('variable', $._form), optional(field('type', seq(repeat($._gap), $._form))),\n00242|             repeat1($._for_part)), loopSymbol('and')),\n00243|         with_clause: $ => seq(loopSymbol('with'), repeat($._gap), choice($._form, seq($._form, repeat($._gap), field('type', $._form))), repeat($._gap), optSeq(loopSymbol(\"=\"), repeat($._gap)), optSeq($._form, repeat($._gap))),\n00244|         do_clause: $ => prec.left(seq(loopSymbol('do'), repeat1(prec.left(seq(repeat($._gap), $._form, repeat($._gap)))))),\n00245|         while_clause: $ => prec.left(seq(choice(loopSymbol('while'), loopSymbol('until')), repeat($._gap), $._form)),\n00246|         repeat_clause: $ => prec.left(seq(loopSymbol('repeat'), repeat($._gap), $._form)),\n00247|         condition_clause: $ => prec.left(choice(seq(choice(loopSymbol('when'), loopSymbol('if'), loopSymbol('unless'), loopSymbol('always'), loopSymbol('thereis'), loopSymbol('never')), repeat($._gap), $._form), loopSymbol(\"else\"))),\n00248|         accumulation_clause: $ => seq($.accumulation_verb, repeat($._gap), $._form, optional(seq(repeat($._gap), loopSymbol('into'), repeat($._gap), $._form))),\n00249|         termination_clause: $ => prec.left(seq(choice(loopSymbol('finally'), loopSymbol('return'), loopSymbol('initially')), repeat($._gap), $._form)),\n00250| \n00251| \n00252|         loop_clause: $ =>\n00253|             seq(choice(\n00254|                 $.for_clause,\n00255|                 $.do_clause,\n00256|                 $.list_lit,\n00257|                 $.while_clause,\n00258|                 $.repeat_clause,\n00259|                 $.accumulation_clause,\n00260|                 $.condition_clause,\n00261|                 $.with_clause,\n00262|                 $.termination_clause,\n00263|                 $.while_clause,\n00264|             )),\n00265| \n00266|         loop_macro: $ =>\n00267|             prec(PREC.SPECIAL,\n00268|                 seq(field('open', \"(\"),\n00269|                     optional($._gap),\n00270|                     clSymbol('loop'),\n00271|                     repeat(choice($.loop_clause, $._gap)),\n00272|                     field('close', \")\"))),\n00273| \n00274|         defun_keyword: _ => prec(10, clSymbol(choice('defun', 'defmacro', 'defgeneric', 'defmethod'))),\n00275| \n00276|         defun_header: $ =>\n00277|             prec(PREC.SPECIAL, choice(\n00278|                 seq(field('keyword', $.defun_keyword),\n00279|                     repeat($._gap),\n00280|                     choice($.unquoting_lit, $.unquote_splicing_lit)\n00281|                 ),\n00282|                 seq(field('keyword', $.defun_keyword),\n00283|                     repeat($._gap),\n00284|                     field('function_name', $._form),\n00285|                     optional(field('specifier', seq(repeat($._gap), choice($.kwd_lit, $.sym_lit)))),\n00286|                     repeat($._gap),\n00287|                     field('lambda_list', choice($.list_lit, $.unquoting_lit))),\n00288|                 seq(field('keyword', alias('lambda', $.defun_keyword)),\n00289|                     repeat($._gap),\n00290|                     field('lambda_list', choice($.list_lit, $.unquoting_lit)))\n00291|             )),\n00292| \n00293|         array_dimension: _ => prec(100, /\\d+[aA]/),\n00294| \n00295|         char_lit: _ =>\n00296|             seq('#', /\\\\([^\\f\\n\\r\\t ()]+|[()])/),\n00297| \n00298|         vec_lit: $ =>\n00299|             prec(PREC.SPECIAL,\n00300|                 choice(\n00301|                     seq(field('open', choice('#0A', '#0a')), choice($.num_lit, $.complex_num_lit)),\n00302|                     seq(field('open', '#'), optional($.array_dimension), $.list_lit))),\n00303| \n00304|         path_lit: $ =>\n00305|             prec(PREC.SPECIAL,\n00306|                 seq(field('open', choice('#P', '#p')), alias(STRING, $.str_lit))),\n00307| \n00308|         _bare_list_lit: $ =>\n00309|             choice(prec(PREC.SPECIAL, $.defun),\n00310|                 prec(PREC.SPECIAL, $.loop_macro),\n00311|                 seq(field('open', \"(\"),\n00312|                     repeat(choice(field('value', $._form), $._gap)),\n00313|                     field('close', \")\"))),\n00314| \n00315|         package_lit: $ => prec(PREC.PACKAGE_LIT, choice(seq(\n00316|             field('package', choice($.sym_lit, 'cl')), // Make optional, instead of keywords?\n00317|             choice(':', '::'),\n00318|             field('symbol', $.sym_lit)\n00319|         ), prec(1, 'cl'))),\n00320| \n00321|         _package_lit_without_slash: $ => seq(\n00322|             field('package', choice($._sym_lit_without_slash, 'cl')), // Make optional, instead of keywords?\n00323|             choice(':', '::'),\n00324|             field('symbol', $._sym_lit_without_slash)\n00325|         ),\n00326| \n00327|         kwd_lit: $ => prec(PREC.KWD_LIT, seq(\n00328|             choice(':', '::'),\n00329|             $.kwd_symbol,\n00330|         )),\n00331| \n00332|         sym_lit: _ =>\n00333|             seq(SYMBOL),\n00334| \n00335|         _sym_lit_without_slash: $ =>\n00336|             alias(repeat1(SYMBOL_WITHOUT_SLASH), $.sym_lit),\n00337| \n00338|         kwd_symbol: _ =>\n00339|             seq(SYMBOL),\n00340| \n00341|         self_referential_reader_macro: _ => /#\\d+[=#]/,\n00342| \n00343|         _form: $ =>\n00344|             seq(optional('#'),\n00345|                 choice(\n00346|                     $.num_lit,\n00347|                     $.fancy_literal,\n00348|                     $.vec_lit,\n00349|                     $.kwd_lit,\n00350|                     // No idea why this is necessary...It is never used but triggers some background magic\n00351|                     alias(seq(field('open', '#'), optional(/\\d+[aA]/), $.list_lit), $.vec_lit),\n00352|                     $.str_lit,\n00353|                     $.self_referential_reader_macro,\n00354|                     $.char_lit,\n00355|                     $.nil_lit,\n00356|                     $.path_lit,\n00357|                     $.sym_lit,\n00358|                     $.package_lit,\n00359|                     $.list_lit,\n00360|                     $.set_lit,\n00361|                     $.read_cond_lit,\n00362|                     $.splicing_read_cond_lit,\n00363|                     $.var_quoting_lit,\n00364|                     $.quoting_lit,\n00365|                     $.syn_quoting_lit,\n00366|                     $.unquote_splicing_lit,\n00367|                     $.unquoting_lit,\n00368|                     $.include_reader_macro,\n00369|                     $.complex_num_lit,\n00370|                     \".\",\n00371|                 )),\n00372| \n00373|         num_lit: _ =>\n00374|             seq(NUMBER, optional(/[sSfFdDlL]/)),\n00375| \n00376|         include_reader_macro: $ =>\n00377|             seq(repeat($._metadata_lit),\n00378|                 field('marker', choice(\"#+\", \"#-\")),\n00379|                 repeat($._gap),\n00380|                 field('condition', $._form),\n00381|                 repeat($._gap),\n00382|                 field('target', $._form)),\n00383| \n00384|         complex_num_lit: $ =>\n00385|             seq(repeat($._metadata_lit),\n00386|                 field('marker', choice(\"#C\", \"#c\")),\n00387|                 repeat($._gap),\n00388|                 '(',\n00389|                 repeat($._gap),\n00390|                 field('real', $.num_lit), // only numbers allowed here\n00391|                 repeat($._gap),\n00392|                 field('imaginary', $.num_lit),\n00393|                 repeat($._gap),\n00394|                 ')'\n00395|             ),\n00396|     }\n00397| });\n00398| \n\n(End of file - total 398 lines)\n</file>",
      "title": "internal/parser/grammars/commonlisp/grammar.js",
      "metadata": {
        "preview": "/*\n * grammar.js\n * Copyright (C) 2021 Stephan Seitz <stephan.seitz@fau.de>\n * Adapted from tree-sitter-clojure\n *\n * Distributed under terms of the MIT license.\n */\n\nconst clojure = require(\"tree-sitter-clojure/grammar\");\n\nconst WHITESPACE_CHAR =\n    /[\\f\\n\\r\\t \\u000B\\u001C\\u001D\\u001E\\u001F\\u2028\\u2029\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2008\\u2009\\u200a\\u205f\\u3000]/;\n\nconst WHITESPACE =\n    token(repeat1(WHITESPACE_CHAR));\n\nconst PREC = {\n    NUM_LIT: 0,\n    NORMAL: 1,\n    PACKAGE_LIT: 2,",
        "truncated": false
      },
      "time": {
        "start": 1768657110387,
        "end": 1768657110391
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110392,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc56f001VZaYuQgluKuvW1",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "EqIkbfrCy",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/internal/parser/grammars/commonlisp/test/corpus/basic.txt"
      },
      "output": "<file>\n00001| ================================================================================\n00002| Block Comments\n00003| ================================================================================\n00004| \n00005| #|(ql.foo:quickload \"cl-project\")\n00006| (defun add (a b) |\n00007|     (+ a b ))|#\n00008| \n00009| (add 8 9)\n00010| \n00011| --------------------------------------------------------------------------------\n00012| \n00013| (source\n00014|   (block_comment)\n00015|   (list_lit\n00016|     (sym_lit)\n00017|     (num_lit)\n00018|     (num_lit)))\n00019| \n00020| ================================================================================\n00021| Block Comments 2\n00022| ================================================================================\n00023| \n00024| (add #|8 |#9)\n00025| \n00026| --------------------------------------------------------------------------------\n00027| \n00028| (source\n00029|   (list_lit\n00030|     (sym_lit)\n00031|     (block_comment)\n00032|     (num_lit)))\n00033| \n00034| ================================================================================\n00035| Quasi-Quoting\n00036| ================================================================================\n00037| \n00038| `(add a ,(b))\n00039| `(add a ,@(b))\n00040| `(add a , b)\n00041| `(add a ,b)\n00042| \n00043| --------------------------------------------------------------------------------\n00044| \n00045| (source\n00046|   (syn_quoting_lit\n00047|     (list_lit\n00048|       (sym_lit)\n00049|       (sym_lit)\n00050|       (unquoting_lit\n00051|         (list_lit\n00052|           (sym_lit)))))\n00053|   (syn_quoting_lit\n00054|     (list_lit\n00055|       (sym_lit)\n00056|       (sym_lit)\n00057|       (unquote_splicing_lit\n00058|         (list_lit\n00059|           (sym_lit)))))\n00060|   (syn_quoting_lit\n00061|     (list_lit\n00062|       (sym_lit)\n00063|       (sym_lit)\n00064|       (unquoting_lit\n00065|         (sym_lit))))\n00066|   (syn_quoting_lit\n00067|     (list_lit\n00068|       (sym_lit)\n00069|       (sym_lit)\n00070|       (unquoting_lit\n00071|         (sym_lit)))))\n00072| \n00073| ================================================================================\n00074| Fancy Literal\n00075| ================================================================================\n00076| \n00077| (|`(add a ,(b))| a)\n00078| \n00079| --------------------------------------------------------------------------------\n00080| \n00081| (source\n00082|   (list_lit\n00083|     (fancy_literal)\n00084|     (sym_lit)))\n00085| \n00086| ================================================================================\n00087| Defun header\n00088| ================================================================================\n00089| (defun a (a b)\n00090|   (car 1 2)\n00091|   2)\n00092| ( defun a (a b)\n00093|   (car 1 2)\n00094|   2)\n00095| \n00096| (defmethod input-gradient :around\n00097|     (lazy-array output-gradient index)\n00098|   (let ((input (nth index (lazy-array-inputs lazy-array)))\n00099|         (value (call-next-method)))\n00100|     (if (petalisp.type-inference:ntype=\n00101|          (element-ntype value)\n00102|          (element-ntype input))\n00103|         value\n00104|         (lazy #'coerce value (element-type input)))))\n00105| --------------------------------------------------------------------------------\n00106| \n00107| (source\n00108|   (list_lit\n00109|     (defun\n00110|       (defun_header\n00111|         (defun_keyword)\n00112|         (sym_lit)\n00113|         (list_lit\n00114|           (sym_lit)\n00115|           (sym_lit)))\n00116|       (list_lit\n00117|         (sym_lit)\n00118|         (num_lit)\n00119|         (num_lit))\n00120|       (num_lit)))\n00121|   (list_lit\n00122|     (defun\n00123|       (defun_header\n00124|         (defun_keyword)\n00125|         (sym_lit)\n00126|         (list_lit\n00127|           (sym_lit)\n00128|           (sym_lit)))\n00129|       (list_lit\n00130|         (sym_lit)\n00131|         (num_lit)\n00132|         (num_lit))\n00133|       (num_lit)))\n00134|   (list_lit\n00135|     (defun\n00136|       (defun_header\n00137|         (defun_keyword)\n00138|         (sym_lit)\n00139|         (kwd_lit\n00140|           (kwd_symbol))\n00141|         (list_lit\n00142|           (sym_lit)\n00143|           (sym_lit)\n00144|           (sym_lit)))\n00145|       (list_lit\n00146|         (sym_lit)\n00147|         (list_lit\n00148|           (list_lit\n00149|             (sym_lit)\n00150|             (list_lit\n00151|               (sym_lit)\n00152|               (sym_lit)\n00153|               (list_lit\n00154|                 (sym_lit)\n00155|                 (sym_lit))))\n00156|           (list_lit\n00157|             (sym_lit)\n00158|             (list_lit\n00159|               (sym_lit))))\n00160|         (list_lit\n00161|           (sym_lit)\n00162|           (list_lit\n00163|             (package_lit\n00164|               (sym_lit)\n00165|               (sym_lit))\n00166|             (list_lit\n00167|               (sym_lit)\n00168|               (sym_lit))\n00169|             (list_lit\n00170|               (sym_lit)\n00171|               (sym_lit)))\n00172|           (sym_lit)\n00173|           (list_lit\n00174|             (sym_lit)\n00175|             (var_quoting_lit\n00176|               (sym_lit))\n00177|             (sym_lit)\n00178|             (list_lit\n00179|               (sym_lit)\n00180|               (sym_lit))))))))\n00181| \n00182| ================================================================================\n00183| Vectors\n00184| ================================================================================\n00185| \n00186| #(  2 3 4)\n00187| #()\n00188| \n00189| --------------------------------------------------------------------------------\n00190| \n00191| (source\n00192|   (vec_lit\n00193|     (list_lit\n00194|       (num_lit)\n00195|       (num_lit)\n00196|       (num_lit)))\n00197|   (vec_lit\n00198|     (list_lit)))\n00199| \n00200| ================================================================================\n00201| Arrays\n00202| ================================================================================\n00203| \n00204| #0A2\n00205| #0A#C(1 2)\n00206| #2A((2 3 4))\n00207| \n00208| --------------------------------------------------------------------------------\n00209| \n00210| (source\n00211|   (vec_lit\n00212|     (num_lit))\n00213|   (vec_lit\n00214|     (complex_num_lit\n00215|       (num_lit)\n00216|       (num_lit)))\n00217|   (vec_lit\n00218|     (array_dimension)\n00219|     (list_lit\n00220|       (list_lit\n00221|         (num_lit)\n00222|         (num_lit)\n00223|         (num_lit)))))\n00224| \n00225| ================================================================================\n00226| Loop Macro\n00227| ================================================================================\n00228| \n00229| (cl:loop for dim-idx in xyz\n00230|                  for letter in (list 'x 'y 'z)\n00231|                  collect (let ((current-range (nth dim-idx iteration-ranges)))\n00232|                            `(, (get-counter-symbol dim-idx) \n00233|                                (+ ,(range-start current-range)\n00234|                                   (* ,(range-step current-range)\n00235|                                      ,(case letter \n00236|                                         (x '(+ thread-idx-x (* block-idx-x block-dim-x)))\n00237|                                         (y '(+ thread-idx-y (* block-idx-y block-dim-y)))\n00238|                                         (z '(+ thread-idx-z (* block-idx-z block-dim-z)))))))))\n00239| --------------------------------------------------------------------------------\n00240| \n00241| (source\n00242|   (list_lit\n00243|     (loop_macro\n00244|       (loop_clause\n00245|         (for_clause\n00246|           (sym_lit)\n00247|           (for_clause_word)\n00248|           (sym_lit)))\n00249|       (loop_clause\n00250|         (for_clause\n00251|           (sym_lit)\n00252|           (for_clause_word)\n00253|           (list_lit\n00254|             (sym_lit)\n00255|             (quoting_lit\n00256|               (sym_lit))\n00257|             (quoting_lit\n00258|               (sym_lit))\n00259|             (quoting_lit\n00260|               (sym_lit)))))\n00261|       (loop_clause\n00262|         (accumulation_clause\n00263|           (accumulation_verb)\n00264|           (list_lit\n00265|             (sym_lit)\n00266|             (list_lit\n00267|               (list_lit\n00268|                 (sym_lit)\n00269|                 (list_lit\n00270|                   (sym_lit)\n00271|                   (sym_lit)\n00272|                   (sym_lit))))\n00273|             (syn_quoting_lit\n00274|               (list_lit\n00275|                 (unquoting_lit\n00276|                   (list_lit\n00277|                     (sym_lit)\n00278|                     (sym_lit)))\n00279|                 (list_lit\n00280|                   (sym_lit)\n00281|                   (unquoting_lit\n00282|                     (list_lit\n00283|                       (sym_lit)\n00284|                       (sym_lit)))\n00285|                   (list_lit\n00286|                     (sym_lit)\n00287|                     (unquoting_lit\n00288|                       (list_lit\n00289|                         (sym_lit)\n00290|                         (sym_lit)))\n00291|                     (unquoting_lit\n00292|                       (list_lit\n00293|                         (sym_lit)\n00294|                         (sym_lit)\n00295|                         (list_lit\n00296|                           (sym_lit)\n00297|                           (quoting_lit\n00298|                             (list_lit\n00299|                               (sym_lit)\n00300|                               (sym_lit)\n00301|                               (list_lit\n00302|                                 (sym_lit)\n00303|                                 (sym_lit)\n00304|                                 (sym_lit)))))\n00305|                         (list_lit\n00306|                           (sym_lit)\n00307|                           (quoting_lit\n00308|                             (list_lit\n00309|                               (sym_lit)\n00310|                               (sym_lit)\n00311|                               (list_lit\n00312|                                 (sym_lit)\n00313|                                 (sym_lit)\n00314|                                 (sym_lit)))))\n00315|                         (list_lit\n00316|                           (sym_lit)\n00317|                           (quoting_lit\n00318|                             (list_lit\n00319|                               (sym_lit)\n00320|                               (sym_lit)\n00321|                               (list_lit\n00322|                                 (sym_lit)\n00323|                                 (sym_lit)\n00324|                                 (sym_lit)))))))))))))))))\n00325| \n00326| ================================================================================\n00327| Loop Macro (Accumulation)\n00328| ================================================================================\n00329| \n00330| (loop for i below 10\n00331|       collect x into a)\n00332| --------------------------------------------------------------------------------\n00333| \n00334| (source\n00335|   (list_lit\n00336|     (loop_macro\n00337|       (loop_clause\n00338|         (for_clause\n00339|           (sym_lit)\n00340|           (for_clause_word)\n00341|           (num_lit)))\n00342|       (loop_clause\n00343|         (accumulation_clause\n00344|           (accumulation_verb)\n00345|           (sym_lit)\n00346|           (sym_lit))))))\n00347| \n00348| ================================================================================\n00349| Loop Macro (finally)\n00350| ================================================================================\n00351| \n00352| (loop for a below 8\n00353|       for x = (+  a)\n00354|       with first-x = (+  a)\n00355|       if (> x 10) return x\n00356|       do (format t \"~A ~A~%\" x first-x)\n00357|       finally (return 3))\n00358| --------------------------------------------------------------------------------\n00359| \n00360| (source\n00361|   (list_lit\n00362|     (loop_macro\n00363|       (loop_clause\n00364|         (for_clause\n00365|           (sym_lit)\n00366|           (for_clause_word)\n00367|           (num_lit)))\n00368|       (loop_clause\n00369|         (for_clause\n00370|           (sym_lit)\n00371|           (for_clause_word)\n00372|           (list_lit\n00373|             (sym_lit)\n00374|             (sym_lit))))\n00375|       (loop_clause\n00376|         (with_clause\n00377|           (sym_lit)\n00378|           (list_lit\n00379|             (sym_lit)\n00380|             (sym_lit))))\n00381|       (loop_clause\n00382|         (condition_clause\n00383|           (list_lit\n00384|             (sym_lit)\n00385|             (sym_lit)\n00386|             (num_lit))))\n00387|       (loop_clause\n00388|         (termination_clause\n00389|           (sym_lit)))\n00390|       (loop_clause\n00391|         (do_clause\n00392|           (list_lit\n00393|             (sym_lit)\n00394|             (sym_lit)\n00395|             (str_lit\n00396|               (format_specifier\n00397|                 (format_directive_type))\n00398|               (format_specifier\n00399|                 (format_directive_type))\n00400|               (format_specifier\n00401|                 (format_directive_type)))\n00402|             (sym_lit)\n00403|             (sym_lit))))\n00404|       (loop_clause\n00405|         (termination_clause\n00406|           (list_lit\n00407|             (sym_lit)\n00408|             (num_lit)))))))\n00409| \n00410| ================================================================================\n00411| Loop Macro (do do do)\n00412| ================================================================================\n00413| \n00414| (loop for a below 8\n00415|       for x = (+  a)\n00416|       with first-x = (+  a)\n00417|       if (> x 10) return x\n00418|       do (format t \"~A ~A~%\" x first-x) (format t \"~A ~A~%\" x first-x)\n00419|       finally (return 3))\n00420| --------------------------------------------------------------------------------\n00421| \n00422| (source\n00423|   (list_lit\n00424|     (loop_macro\n00425|       (loop_clause\n00426|         (for_clause\n00427|           (sym_lit)\n00428|           (for_clause_word)\n00429|           (num_lit)))\n00430|       (loop_clause\n00431|         (for_clause\n00432|           (sym_lit)\n00433|           (for_clause_word)\n00434|           (list_lit\n00435|             (sym_lit)\n00436|             (sym_lit))))\n00437|       (loop_clause\n00438|         (with_clause\n00439|           (sym_lit)\n00440|           (list_lit\n00441|             (sym_lit)\n00442|             (sym_lit))))\n00443|       (loop_clause\n00444|         (condition_clause\n00445|           (list_lit\n00446|             (sym_lit)\n00447|             (sym_lit)\n00448|             (num_lit))))\n00449|       (loop_clause\n00450|         (termination_clause\n00451|           (sym_lit)))\n00452|       (loop_clause\n00453|         (do_clause\n00454|           (list_lit\n00455|             (sym_lit)\n00456|             (sym_lit)\n00457|             (str_lit\n00458|               (format_specifier\n00459|                 (format_directive_type))\n00460|               (format_specifier\n00461|                 (format_directive_type))\n00462|               (format_specifier\n00463|                 (format_directive_type)))\n00464|             (sym_lit)\n00465|             (sym_lit))))\n00466|       (loop_clause\n00467|         (list_lit\n00468|           (sym_lit)\n00469|           (sym_lit)\n00470|           (str_lit\n00471|             (format_specifier\n00472|               (format_directive_type))\n00473|             (format_specifier\n00474|               (format_directive_type))\n00475|             (format_specifier\n00476|               (format_directive_type)))\n00477|           (sym_lit)\n00478|           (sym_lit)))\n00479|       (loop_clause\n00480|         (termination_clause\n00481|           (list_lit\n00482|             (sym_lit)\n00483|             (num_lit)))))))\n00484| \n00485| ================================================================================\n00486| Conses\n00487| ================================================================================\n00488| \n00489| (2 . 3)\n00490| (2 . ( 2 3))\n00491| --------------------------------------------------------------------------------\n00492| \n00493| (source\n00494|   (list_lit\n00495|     (num_lit)\n00496|     (num_lit))\n00497|   (list_lit\n00498|     (num_lit)\n00499|     (list_lit\n00500|       (num_lit)\n00501|       (num_lit))))\n00502| \n00503| ================================================================================\n00504| Complex Numbers\n00505| ================================================================================\n00506| \n00507| #C(2 3)\n00508| #C\n00509| ( 2 1)\n00510| \n00511| #C(-2 1)\n00512| --------------------------------------------------------------------------------\n00513| \n00514| (source\n00515|   (complex_num_lit\n00516|     (num_lit)\n00517|     (num_lit))\n00518|   (complex_num_lit\n00519|     (num_lit)\n00520|     (num_lit))\n00521|   (complex_num_lit\n00522|     (num_lit)\n00523|     (num_lit)))\n00524| \n00525| ================================================================================\n00526| Reader Macros\n00527| ================================================================================\n00528| #+unix(loop)\n00529| \n00530| #+windows\n00531| (loop)\n00532| \n00533| --------------------------------------------------------------------------------\n00534| \n00535| (source\n00536|   (include_reader_macro\n00537|     (sym_lit)\n00538|     (list_lit\n00539|       (loop_macro)))\n00540|   (include_reader_macro\n00541|     (sym_lit)\n00542|     (list_lit\n00543|       (loop_macro))))\n00544| \n00545| ================================================================================\n00546| Packages\n00547| ================================================================================\n00548| \n00549| foo:baz\n00550| foo.bar:baz\n00551| (foo.bar:baz)\n00552| --------------------------------------------------------------------------------\n00553| \n00554| (source\n00555|   (package_lit\n00556|     (sym_lit)\n00557|     (sym_lit))\n00558|   (package_lit\n00559|     (sym_lit)\n00560|     (sym_lit))\n00561|   (list_lit\n00562|     (package_lit\n00563|       (sym_lit)\n00564|       (sym_lit))))\n00565| \n00566| ================================================================================\n00567| Keywords\n00568| ================================================================================\n00569| \n00570| :foo\n00571| \n00572| :foo.bar\n00573| --------------------------------------------------------------------------------\n00574| \n00575| (source\n00576|   (kwd_lit\n00577|     (kwd_symbol))\n00578|   (kwd_lit\n00579|     (kwd_symbol)))\n00580| \n00581| ================================================================================\n00582| Functions with numbers (TODO!!!)\n00583| ================================================================================\n00584| \n00585| 1+\n00586| 1-\n00587| --------------------------------------------------------------------------------\n00588| \n00589| (source\n00590|   (sym_lit)\n00591|   (sym_lit))\n00592| \n00593| ================================================================================\n00594| Petalisp shapes\n00595| ================================================================================\n00596| \n00597| (~ (* w h) ~ 128)\n00598| --------------------------------------------------------------------------------\n00599| \n00600| (source\n00601|   (list_lit\n00602|     (sym_lit)\n00603|     (list_lit\n00604|       (sym_lit)\n00605|       (sym_lit)\n00606|       (sym_lit))\n00607|     (sym_lit)\n00608|     (num_lit)))\n00609| \n00610| ================================================================================\n00611| Chars\n00612| ================================================================================\n00613| \n00614| #\\?\n00615| #\\,\n00616| #\\-\n00617| #\\:\n00618| #\\/\n00619| --------------------------------------------------------------------------------\n00620| \n00621| (source\n00622|   (char_lit)\n00623|   (char_lit)\n00624|   (char_lit)\n00625|   (char_lit)\n00626|   (char_lit))\n00627| \n00628| ================================================================================\n00629| Dotted literals\n00630| ================================================================================\n00631| \n00632| foo.bar\n00633| foo. bar\n00634| .bar\n00635| #.bar\n00636| --------------------------------------------------------------------------------\n00637| \n00638| (source\n00639|   (sym_lit)\n00640|   (sym_lit)\n00641|   (sym_lit)\n00642|   (sym_lit)\n00643|   (sym_lit))\n00644| \n00645| ================================================================================\n00646| Loop (else)\n00647| ================================================================================\n00648| \n00649| (loop for input-index from 0\n00650|                      for input-constraint across (transformation-input-mask transformation)\n00651|                      if (not input-constraint)\n00652|                        collect (transformation-input-symbol input-index)\n00653|                      else\n00654|                        collect input-constraint)\n00655| --------------------------------------------------------------------------------\n00656| \n00657| (source\n00658|   (list_lit\n00659|     (loop_macro\n00660|       (loop_clause\n00661|         (for_clause\n00662|           (sym_lit)\n00663|           (for_clause_word)\n00664|           (num_lit)))\n00665|       (loop_clause\n00666|         (for_clause\n00667|           (sym_lit)\n00668|           (for_clause_word)\n00669|           (list_lit\n00670|             (sym_lit)\n00671|             (sym_lit))))\n00672|       (loop_clause\n00673|         (condition_clause\n00674|           (list_lit\n00675|             (sym_lit)\n00676|             (sym_lit))))\n00677|       (loop_clause\n00678|         (accumulation_clause\n00679|           (accumulation_verb)\n00680|           (list_lit\n00681|             (sym_lit)\n00682|             (sym_lit))))\n00683|       (loop_clause\n00684|         (condition_clause))\n00685|       (loop_clause\n00686|         (accumulation_clause\n00687|           (accumulation_verb)\n00688|           (sym_lit))))))\n00689| \n00690| ================================================================================\n00691| Multiple gaps in Loop\n00692| ================================================================================\n00693| \n00694| (defmethod cl-dot:graph-object-points-to\n00695|     ((graph any-graph) node)\n00696|   (loop for edge in (graphviz-potential-edges graph node)\n00697|         append\n00698|         ;; There must be a more graceful way to loop over sequences...\n00699|         (loop for target in (coerce (graphviz-outgoing-edge-targets graph edge node) 'list)\n00700|               for edge-number from 0\n00701|               collect\n00702|               (make-instance 'cl-dot:attributed\n00703|                 :attributes (graphviz-edge-attributes graph edge node target edge-number)\n00704|                 :object target))))\n00705| \n00706| --------------------------------------------------------------------------------\n00707| \n00708| (source\n00709|   (list_lit\n00710|     (defun\n00711|       (defun_header\n00712|         (defun_keyword)\n00713|         (package_lit\n00714|           (sym_lit)\n00715|           (sym_lit))\n00716|         (list_lit\n00717|           (list_lit\n00718|             (sym_lit)\n00719|             (sym_lit))\n00720|           (sym_lit)))\n00721|       (list_lit\n00722|         (loop_macro\n00723|           (loop_clause\n00724|             (for_clause\n00725|               (sym_lit)\n00726|               (for_clause_word)\n00727|               (list_lit\n00728|                 (sym_lit)\n00729|                 (sym_lit)\n00730|                 (sym_lit))))\n00731|           (loop_clause\n00732|             (accumulation_clause\n00733|               (accumulation_verb)\n00734|               (comment)\n00735|               (list_lit\n00736|                 (loop_macro\n00737|                   (loop_clause\n00738|                     (for_clause\n00739|                       (sym_lit)\n00740|                       (for_clause_word)\n00741|                       (list_lit\n00742|                         (sym_lit)\n00743|                         (list_lit\n00744|                           (sym_lit)\n00745|                           (sym_lit)\n00746|                           (sym_lit)\n00747|                           (sym_lit))\n00748|                         (quoting_lit\n00749|                           (sym_lit)))))\n00750|                   (loop_clause\n00751|                     (for_clause\n00752|                       (sym_lit)\n00753|                       (for_clause_word)\n00754|                       (num_lit)))\n00755|                   (loop_clause\n00756|                     (accumulation_clause\n00757|                       (accumulation_verb)\n00758|                       (list_lit\n00759|                         (sym_lit)\n00760|                         (quoting_lit\n00761|                           (package_lit\n00762|                             (sym_lit)\n00763|                             (sym_lit)))\n00764|                         (kwd_lit\n00765|                           (kwd_symbol))\n00766|                         (list_lit\n00767|                           (sym_lit)\n00768|                           (sym_lit)\n00769|                           (sym_lit)\n00770|                           (sym_lit)\n00771|                           (sym_lit)\n00772|                           (sym_lit))\n00773|                         (kwd_lit\n00774|                           (kwd_symbol))\n00775|                         (sym_lit)))))))))))))\n00776| \n00777| ================================================================================\n00778| Unquoting in defun 2\n00779| ================================================================================\n00780|  `((defmacro ,name))\n00781|  `((defmacro ,name))\n00782|  `((defmacro ,name)\n00783|          ,(function-location (macro-function name)))\n00784| --------------------------------------------------------------------------------\n00785| \n00786| (source\n00787|   (syn_quoting_lit\n00788|     (list_lit\n00789|       (list_lit\n00790|         (defun\n00791|           (defun_header\n00792|             (defun_keyword)\n00793|             (unquoting_lit\n00794|               (sym_lit)))))))\n00795|   (syn_quoting_lit\n00796|     (list_lit\n00797|       (list_lit\n00798|         (defun\n00799|           (defun_header\n00800|             (defun_keyword)\n00801|             (unquoting_lit\n00802|               (sym_lit)))))))\n00803|   (syn_quoting_lit\n00804|     (list_lit\n00805|       (list_lit\n00806|         (defun\n00807|           (defun_header\n00808|             (defun_keyword)\n00809|             (unquoting_lit\n00810|               (sym_lit)))))\n00811|       (unquoting_lit\n00812|         (list_lit\n00813|           (sym_lit)\n00814|           (list_lit\n00815|             (sym_lit)\n00816|             (sym_lit)))))))\n00817| \n00818| ================================================================================\n00819| Weird quoting\n00820| ================================================================================\n00821| \n00822| (deftype worker-pool-workers ()\n00823|   `simple-vector)\n00824| \n00825| --------------------------------------------------------------------------------\n00826| \n00827| (source\n00828|   (list_lit\n00829|     (sym_lit)\n00830|     (sym_lit)\n00831|     (list_lit)\n00832|     (syn_quoting_lit\n00833|       (sym_lit))))\n00834| \n00835| ================================================================================\n00836| Num Literals\n00837| ================================================================================\n00838| \n00839| 0f\n00840| (deftype zero ()\n00841|   '(member 0 0S0 -0S0 0F0 -0F0 0D0 -0D0 0L0 -0L0\n00842|     #C(0S0 0S0) #C(0S0 -0S0) #C(-0S0 0S0) #C(-0S0 -0S0)\n00843|     #C(0F0 0F0) #C(0F0 -0F0) #C(-0F0 0F0) #C(-0F0 -0F0)\n00844|     #C(0D0 0D0) #C(0D0 -0D0) #C(-0D0 0D0) #C(-0D0 -0D0)\n00845|     #C(0L0 0L0) #C(0L0 -0L0) #C(-0L0 0L0) #C(-0L0 -0L0)))\n00846| --------------------------------------------------------------------------------\n00847| \n00848| (source\n00849|   (sym_lit)\n00850|   (list_lit\n00851|     (sym_lit)\n00852|     (sym_lit)\n00853|     (list_lit)\n00854|     (quoting_lit\n00855|       (list_lit\n00856|         (sym_lit)\n00857|         (num_lit)\n00858|         (num_lit)\n00859|         (num_lit)\n00860|         (num_lit)\n00861|         (num_lit)\n00862|         (num_lit)\n00863|         (num_lit)\n00864|         (num_lit)\n00865|         (num_lit)\n00866|         (complex_num_lit\n00867|           (num_lit)\n00868|           (num_lit))\n00869|         (complex_num_lit\n00870|           (num_lit)\n00871|           (num_lit))\n00872|         (complex_num_lit\n00873|           (num_lit)\n00874|           (num_lit))\n00875|         (complex_num_lit\n00876|           (num_lit)\n00877|           (num_lit))\n00878|         (complex_num_lit\n00879|           (num_lit)\n00880|           (num_lit))\n00881|         (complex_num_lit\n00882|           (num_lit)\n00883|           (num_lit))\n00884|         (complex_num_lit\n00885|           (num_lit)\n00886|           (num_lit))\n00887|         (complex_num_lit\n00888|           (num_lit)\n00889|           (num_lit))\n00890|         (complex_num_lit\n00891|           (num_lit)\n00892|           (num_lit))\n00893|         (complex_num_lit\n00894|           (num_lit)\n00895|           (num_lit))\n00896|         (complex_num_lit\n00897|           (num_lit)\n00898|           (num_lit))\n00899|         (complex_num_lit\n00900|           (num_lit)\n00901|           (num_lit))\n00902|         (complex_num_lit\n00903|           (num_lit)\n00904|           (num_lit))\n00905|         (complex_num_lit\n00906|           (num_lit)\n00907|           (num_lit))\n00908|         (complex_num_lit\n00909|           (num_lit)\n00910|           (num_lit))\n00911|         (complex_num_lit\n00912|           (num_lit)\n00913|           (num_lit))))))\n00914| \n00915| ================================================================================\n00916| Format\n00917| ================================================================================\n00918| \n00919| \"~S\" \t\n00920| \"~3,-4:@s\"\n00921| \t\n00922| \"~,+4S\"\n00923| \n00924| (format T \"~8,0b\" 5)\n00925| (format T \"~v,'0b\" 8 5)\n00926| (load \"~/quicklisp/setup\")\n00927| \n00928| 2\n00929| (load \"~/foo:quicklisp/setup\")\n00930| \n00931| --------------------------------------------------------------------------------\n00932| \n00933| (source\n00934|   (str_lit\n00935|     (format_specifier\n00936|       (format_directive_type)))\n00937|   (str_lit\n00938|     (format_specifier\n00939|       (format_modifiers\n00940|         (num_lit)\n00941|         (num_lit))\n00942|       (format_directive_type)))\n00943|   (str_lit\n00944|     (format_specifier\n00945|       (format_directive_type\n00946|         (num_lit))))\n00947|   (list_lit\n00948|     (sym_lit)\n00949|     (sym_lit)\n00950|     (str_lit\n00951|       (format_specifier\n00952|         (format_directive_type\n00953|           (num_lit)\n00954|           (num_lit))))\n00955|     (num_lit))\n00956|   (list_lit\n00957|     (sym_lit)\n00958|     (sym_lit)\n00959|     (str_lit\n00960|       (format_specifier\n00961|         (format_prefix_parameters)\n00962|         (format_directive_type\n00963|           (char_lit))))\n00964|     (num_lit)\n00965|     (num_lit))\n00966|   (list_lit\n00967|     (sym_lit)\n00968|     (str_lit\n00969|       (format_specifier\n00970|         (format_directive_type\n00971|           (sym_lit)))))\n00972|   (num_lit)\n00973|   (list_lit\n00974|     (sym_lit)\n00975|     (str_lit\n00976|       (format_specifier\n00977|         (format_directive_type\n00978|           (package_lit\n00979|             (sym_lit)\n00980|             (sym_lit)))))))\n00981| \n00982| ================================================================================\n00983| Path Literals\n00984| ================================================================================\n00985| \n00986| #P\"t/global_kernel.ptx\"\n00987| #P\"~/dev/foo\"\n00988| \n00989| --------------------------------------------------------------------------------\n00990| \n00991| (source\n00992|   (path_lit\n00993|     (str_lit))\n00994|   (path_lit\n00995|     (str_lit)))\n00996| \n00997| ================================================================================\n00998| Weird error\n00999| ================================================================================\n01000| \n01001| (in-package :common-lisp-user)\n01002| (cl:in-package #:common-lisp-user)\n01003| \n01004| --------------------------------------------------------------------------------\n01005| \n01006| (source\n01007|   (list_lit\n01008|     (sym_lit)\n01009|     (kwd_lit\n01010|       (kwd_symbol)))\n01011|   (list_lit\n01012|     (package_lit\n01013|       (sym_lit))\n01014|     (kwd_lit\n01015|       (kwd_symbol))))\n01016| \n01017| ================================================================================\n01018| Trailing sharps\n01019| ================================================================================\n01020| \n01021| \n01022| (sequence #a#)\n01023| (sequence #1#)\n01024| --------------------------------------------------------------------------------\n01025| \n01026| (source\n01027|   (list_lit\n01028|     (sym_lit)\n01029|     (sym_lit))\n01030|   (list_lit\n01031|     (sym_lit)\n01032|     (self_referential_reader_macro)))\n01033| \n01034| ================================================================================\n01035| https://lisptips.com/post/44370032877/literal-syntax-for-integers\n01036| ================================================================================\n01037| \n01038| #2r11010101  ;Another way of writing 213 decimal  \n01039| #b11010101   ;Ditto                               \n01040| #b+11010101  ;Ditto                               \n01041| #o325        ;Ditto, in octal radix               \n01042| #xD5         ;Ditto, in hexadecimal radix         \n01043| #16r+D5      ;Ditto                               \n01044| #o-300       ;Decimal -192, written in base 8     \n01045| #3r-21010    ;Same thing in base 3                \n01046| #25R-7H      ;Same thing in base 25               \n01047| #xACCEDED    ;181202413, in hexadecimal radix\n01048| --------------------------------------------------------------------------------\n01049| \n01050| (source\n01051|   (num_lit)\n01052|   (comment)\n01053|   (num_lit)\n01054|   (comment)\n01055|   (num_lit)\n01056|   (comment)\n01057|   (num_lit)\n01058|   (comment)\n01059|   (num_lit)\n01060|   (comment)\n01061|   (sym_lit)\n01062|   (comment)\n01063|   (num_lit)\n01064|   (comment)\n01065|   (sym_lit)\n01066|   (comment)\n01067|   (sym_lit)\n01068|   (comment)\n01069|   (num_lit)\n01070|   (comment))\n01071| \n01072| ================================================================================\n01073| Self-references\n01074| ================================================================================\n01075| (let ((position (mismatch #1=\"MemTotal:\" line)))\n01076|                              (when (= position (length #1#))\n01077|                                (return\n01078|                                  (parse-size line :start position))))\n01079| --------------------------------------------------------------------------------\n01080| \n01081| (source\n01082|   (list_lit\n01083|     (sym_lit)\n01084|     (list_lit\n01085|       (list_lit\n01086|         (sym_lit)\n01087|         (list_lit\n01088|           (sym_lit)\n01089|           (self_referential_reader_macro)\n01090|           (str_lit)\n01091|           (sym_lit))))\n01092|     (list_lit\n01093|       (sym_lit)\n01094|       (list_lit\n01095|         (sym_lit)\n01096|         (sym_lit)\n01097|         (list_lit\n01098|           (sym_lit)\n01099|           (self_referential_reader_macro)))\n01100|       (list_lit\n01101|         (sym_lit)\n01102|         (list_lit\n01103|           (sym_lit)\n01104|           (sym_lit)\n01105|           (kwd_lit\n01106|             (kwd_symbol))\n01107|           (sym_lit))))))\n01108| \n01109| ================================================================================\n01110| @ in defun identifiers\n01111| ================================================================================\n01112| ;; this highlights properly\n01113| (defun foo (bar)                                                                                                                                                                                         \n01114|   (baz))                                                                                                                                                                                                     \n01115| \n01116| ;; this doesn't and breaks all highlighting below                                                                                                                                                                                                        \n01117| (defun @foo (bar)                                                                                                                                                                                        \n01118|   (baz))\n01119| --------------------------------------------------------------------------------\n01120| \n01121| (source\n01122|   (comment)\n01123|   (list_lit\n01124|     (defun\n01125|       (defun_header\n01126|         (defun_keyword)\n01127|         (sym_lit)\n01128|         (list_lit\n01129|           (sym_lit)))\n01130|       (list_lit\n01131|         (sym_lit))))\n01132|   (comment)\n01133|   (list_lit\n01134|     (defun\n01135|       (defun_header\n01136|         (defun_keyword)\n01137|         (sym_lit)\n01138|         (list_lit\n01139|           (sym_lit)))\n01140|       (list_lit\n01141|         (sym_lit)))))\n01142| \n01143| ================================================================================\n01144| Issue #5 (defpackage)\n01145| ================================================================================\n01146| (defpackage foo-bar\n01147|   (:use cl))\n01148| --------------------------------------------------------------------------------\n01149| \n01150| (source\n01151|   (list_lit\n01152|     (sym_lit)\n01153|     (sym_lit)\n01154|     (list_lit\n01155|       (kwd_lit\n01156|         (kwd_symbol))\n01157|       (package_lit))))\n01158| \n01159| ================================================================================\n01160| Issue #6 (#\\Replacement_Character)\n01161| ================================================================================\n01162| #\\Replacement_Character\n01163| --------------------------------------------------------------------------------\n01164| \n01165| (source\n01166|   (char_lit))\n01167| \n01168| ================================================================================\n01169| loop with\n01170| ================================================================================\n01171| (loop with values)\n01172| (loop with values = a)\n01173| (loop with values\n01174|   finally\n01175|   (return values))\n01176| --------------------------------------------------------------------------------\n01177| \n01178| (source\n01179|   (list_lit\n01180|     (loop_macro\n01181|       (loop_clause\n01182|         (with_clause\n01183|           (sym_lit)))))\n01184|   (list_lit\n01185|     (loop_macro\n01186|       (loop_clause\n01187|         (with_clause\n01188|           (sym_lit)\n01189|           (sym_lit)))))\n01190|   (list_lit\n01191|     (loop_macro\n01192|       (loop_clause\n01193|         (with_clause\n01194|           (sym_lit)))\n01195|       (loop_clause\n01196|         (termination_clause\n01197|           (list_lit\n01198|             (sym_lit)\n01199|             (sym_lit)))))))\n01200| \n01201| ================================================================================\n01202| loop with 2\n01203| ================================================================================\n01204| (loop with consecutive-yields fixnum = 0)\n01205| (loop with consecutive-yields fixnum = 0 do\n01206|  (block block))\n01207| \n01208| --------------------------------------------------------------------------------\n01209| \n01210| (source\n01211|   (list_lit\n01212|     (loop_macro\n01213|       (loop_clause\n01214|         (with_clause\n01215|           (sym_lit)\n01216|           (sym_lit)\n01217|           (num_lit)))))\n01218|   (list_lit\n01219|     (loop_macro\n01220|       (loop_clause\n01221|         (with_clause\n01222|           (sym_lit)\n01223|           (sym_lit)\n01224|           (num_lit)))\n01225|       (loop_clause\n01226|         (do_clause\n01227|           (list_lit\n01228|             (sym_lit)\n01229|             (sym_lit)))))))\n01230| \n01231| ================================================================================\n01232| Loop with keywords (TODO: do should not by type of with!)\n01233| ================================================================================\n01234| (loop :with b :do\n01235|    (setq b\n01236|          x)\n01237|    )\n01238| --------------------------------------------------------------------------------\n01239| \n01240| (source\n01241|   (list_lit\n01242|     (loop_macro\n01243|       (loop_clause\n01244|         (with_clause\n01245|           (sym_lit)\n01246|           (kwd_lit\n01247|             (kwd_symbol))\n01248|           (list_lit\n01249|             (sym_lit)\n01250|             (sym_lit)\n01251|             (sym_lit)))))))\n01252| \n01253| ================================================================================\n01254| Loop with keywords 2\n01255| ================================================================================\n01256| \n01257|  (loop\n01258|           for id upfrom 0\n01259|           with frame = (nth-frame-list index))\n01260| --------------------------------------------------------------------------------\n01261| \n01262| (source\n01263|   (list_lit\n01264|     (loop_macro\n01265|       (loop_clause\n01266|         (for_clause\n01267|           (sym_lit)\n01268|           (for_clause_word)\n01269|           (num_lit)))\n01270|       (loop_clause\n01271|         (with_clause\n01272|           (sym_lit)\n01273|           (list_lit\n01274|             (sym_lit)\n01275|             (sym_lit)))))))\n01276| \n01277| ================================================================================\n01278| with type should be symbol or list (TODO!!!)\n01279| ================================================================================\n01280| (loop :with b :do\n01281|    (setq b x))\n01282| --------------------------------------------------------------------------------\n01283| \n01284| (source\n01285|   (list_lit\n01286|     (loop_macro\n01287|       (loop_clause\n01288|         (with_clause\n01289|           (sym_lit)\n01290|           (kwd_lit\n01291|             (kwd_symbol))\n01292|           (list_lit\n01293|             (sym_lit)\n01294|             (sym_lit)\n01295|             (sym_lit)))))))\n01296| \n01297| ================================================================================\n01298| Backslashes in strings\n01299| ================================================================================\n01300|   \" \\( '\\), \\( \\) \"\n01301| \n01302| --------------------------------------------------------------------------------\n01303| \n01304| (source\n01305|   (str_lit))\n01306| \n01307| ================================================================================\n01308| Chars #\\(\n01309| ================================================================================\n01310|  (write-char #\\( stream)\n01311| \n01312| --------------------------------------------------------------------------------\n01313| \n01314| (source\n01315|   (list_lit\n01316|     (sym_lit)\n01317|     (char_lit)\n01318|     (sym_lit)))\n01319| \n01320| ================================================================================\n01321| Issue #10\n01322| ================================================================================\n01323| \n01324| (loop for s in symbols                                                    \n01325|       maximizing (length (symbol-name s)))\n01326| \n01327| --------------------------------------------------------------------------------\n01328| \n01329| (source\n01330|   (list_lit\n01331|     (loop_macro\n01332|       (loop_clause\n01333|         (for_clause\n01334|           (sym_lit)\n01335|           (for_clause_word)\n01336|           (sym_lit)))\n01337|       (loop_clause\n01338|         (accumulation_clause\n01339|           (accumulation_verb)\n01340|           (list_lit\n01341|             (sym_lit)\n01342|             (list_lit\n01343|               (sym_lit)\n01344|               (sym_lit))))))))\n01345| \n\n(End of file - total 1345 lines)\n</file>",
      "title": "internal/parser/grammars/commonlisp/test/corpus/basic.txt",
      "metadata": {
        "preview": "================================================================================\nBlock Comments\n================================================================================\n\n#|(ql.foo:quickload \"cl-project\")\n(defun add (a b) |\n    (+ a b ))|#\n\n(add 8 9)\n\n--------------------------------------------------------------------------------\n\n(source\n  (block_comment)\n  (list_lit\n    (sym_lit)\n    (num_lit)\n    (num_lit)))\n\n================================================================================",
        "truncated": false
      },
      "time": {
        "start": 1768657110383,
        "end": 1768657110391
      }
    }
  }
}
{
  "type": "tool_use",
  "timestamp": 1768657110393,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc571001E2u7Plka1WN8eC",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "tool",
    "callID": "ejUWwZxtr",
    "tool": "read",
    "state": {
      "status": "completed",
      "input": {
        "filePath": "/home/heefoo/codeloom/internal/parser/grammars/commonlisp/README.md"
      },
      "output": "<file>\n00001| # tree-sitter-commonlisp\n00002| \n00003| [![CI][ci]](https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/actions/workflows/ci.yml)\n00004| [![discord][discord]](https://discord.gg/w7nTvsVJhm)\n00005| [![matrix][matrix]](https://matrix.to/#/#tree-sitter-chat:matrix.org)\n00006| [![npm][npm]](https://www.npmjs.com/package/tree-sitter-commonlisp)\n00007| [![crates][crates]](https://crates.io/crates/tree-sitter-commonlisp)\n00008| [![pypi][pypi]](https://pypi.org/project/tree-sitter-commonlisp)\n00009| \n00010| WIP. Goal is to have a better syntax highlighting for Neovim\n00011| and some semantic refactoring https://github.com/nvim-treesitter/nvim-treesitter-refactor/.\n00012| \n00013| All praise goes to https://github.com/sogaiu/tree-sitter-clojure which is extended by this grammar.\n00014| \n00015| TODOs:\n00016| \n00017| - support number literals that are different from clojure (e.g. `.9`)\n00018| \n00019| Macros with special respresentation in syntax tree (when written with lowercase letters):\n00020| \n00021| - defun and friends (e.g. defmethod)\n00022| - loop macro\n00023| \n00024| This grammar is used in https://github.com/Wilfred/difftastic to generate syntax-ware diffs for Common Lisp.\n00025| \n00026| ## Usage\n00027| \n00028| - C/C++\n00029|    - compilation run `make` (optional `make install`)\n00030|    - Follow the [Guide on using tree-sitter parsers](https://tree-sitter.github.io/tree-sitter/using-parsers/1-getting-started.html#getting-started)\n00031|    - set `tree_sitter_commonlisp()` as language on your Tree-Sitter parser from [`tree_sitter_commonlisp.h`](https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/blob/4d2a2247bb0ec117193ef33e3ce546a6781c5bf5/bindings/c/tree-sitter-commonlisp.h#L10-L10)\n00032|     ```c\n00033|     ts_parser_set_language(parser, tree_sitter_commonlisp());\n00034|      ```\n00035| \n00036| - Python (`pip install tree-sitter-commonlisp tree-sitter`)\n00037|   https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/blob/4d2a2247bb0ec117193ef33e3ce546a6781c5bf5/bindings/python/tests/test_import.py#L15-L23\n00038| - Rust `cargo add tree-sitter tree-sitter-grammars`\n00039|   https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/blob/4d2a2247bb0ec117193ef33e3ce546a6781c5bf5/bindings/rust/lib.rs#L47-L50\n00040| - Swift\n00041|   https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/blob/4d2a2247bb0ec117193ef33e3ce546a6781c5bf5/bindings/swift/TreeSitterCommonlispTests/TreeSitterCommonlispTests.swift#L3-L13\n00042| - Go\n00043|   https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/blob/4d2a2247bb0ec117193ef33e3ce546a6781c5bf5/bindings/go/binding_test.go#L1-L15\n00044| \n00045| [ci]: https://img.shields.io/github/actions/workflow/status/tree-sitter-grammars/tree-sitter-commonlisp/ci.yml?logo=github&label=CI\n00046| [discord]: https://img.shields.io/discord/1063097320771698699?logo=discord&label=discord\n00047| [matrix]: https://img.shields.io/matrix/tree-sitter-chat%3Amatrix.org?logo=matrix&label=matrix\n00048| [npm]: https://img.shields.io/npm/v/tree-sitter-commonlisp?logo=npm\n00049| [crates]: https://img.shields.io/crates/v/tree-sitter-commonlisp?logo=rust\n00050| [pypi]: https://img.shields.io/pypi/v/tree-sitter-commonlisp?logo=pypi&logoColor=ffd242\n00051| \n\n(End of file - total 51 lines)\n</file>",
      "title": "internal/parser/grammars/commonlisp/README.md",
      "metadata": {
        "preview": "# tree-sitter-commonlisp\n\n[![CI][ci]](https://github.com/tree-sitter-grammars/tree-sitter-commonlisp/actions/workflows/ci.yml)\n[![discord][discord]](https://discord.gg/w7nTvsVJhm)\n[![matrix][matrix]](https://matrix.to/#/#tree-sitter-chat:matrix.org)\n[![npm][npm]](https://www.npmjs.com/package/tree-sitter-commonlisp)\n[![crates][crates]](https://crates.io/crates/tree-sitter-commonlisp)\n[![pypi][pypi]](https://pypi.org/project/tree-sitter-commonlisp)\n\nWIP. Goal is to have a better syntax highlighting for Neovim\nand some semantic refactoring https://github.com/nvim-treesitter/nvim-treesitter-refactor/.\n\nAll praise goes to https://github.com/sogaiu/tree-sitter-clojure which is extended by this grammar.\n\nTODOs:\n\n- support number literals that are different from clojure (e.g. `.9`)\n\nMacros with special respresentation in syntax tree (when written with lowercase letters):\n",
        "truncated": false
      },
      "time": {
        "start": 1768657110386,
        "end": 1768657110392
      }
    }
  }
}
{
  "type": "step_finish",
  "timestamp": 1768657110401,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2dc57800167Vj0Nnjqk9IZQ",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2d993a0016ZPh6LGDWotNX8",
    "type": "step-finish",
    "reason": "tool-calls",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160",
    "cost": 0.042818,
    "tokens": {
      "input": 20512,
      "output": 299,
      "reasoning": 0,
      "cache": {
        "read": 0,
        "write": 0
      }
    }
  }
}
{
  "type": "step_start",
  "timestamp": 1768657125734,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2e0165001MUrzPLmEfvNcE5",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2dc590001SrjX4G4psbQ88q",
    "type": "step-start",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160"
  }
}
{
  "type": "step_finish",
  "timestamp": 1768657185736,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2eebc3001wZjXp2v6HrudxM",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2dc590001SrjX4G4psbQ88q",
    "type": "step-finish",
    "reason": "tool-calls",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160",
    "cost": 0.154582,
    "tokens": {
      "input": 77030,
      "output": 87,
      "reasoning": 0,
      "cache": {
        "read": 0,
        "write": 0
      }
    }
  }
}
{
  "type": "step_start",
  "timestamp": 1768657189080,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2ef8d7001si3Zv5Bml1A5fW",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2eebd8001cxZdEyxP0NdFUT",
    "type": "step-start",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160"
  }
}
{
  "type": "step_finish",
  "timestamp": 1768657249083,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc2fe335001b3ebbp81n8MQbg",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2eebd8001cxZdEyxP0NdFUT",
    "type": "step-finish",
    "reason": "tool-calls",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160",
    "cost": 0.15484,
    "tokens": {
      "input": 77159,
      "output": 87,
      "reasoning": 0,
      "cache": {
        "read": 0,
        "write": 0
      }
    }
  }
}
{
  "type": "step_start",
  "timestamp": 1768657264812,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc3020ab001wUKqAJh3WxdFUQ",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2fe344001wmyKUuVenirqji",
    "type": "step-start",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160"
  }
}
{
  "type": "step_finish",
  "timestamp": 1768657324815,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc310b08001kn70FVWRHFwPBo",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc2fe344001wmyKUuVenirqji",
    "type": "step-finish",
    "reason": "tool-calls",
    "snapshot": "c1e545dbb9eb50d2adf5eb844e4e71fbfc6d4160",
    "cost": 0.155014,
    "tokens": {
      "input": 77288,
      "output": 73,
      "reasoning": 0,
      "cache": {
        "read": 0,
        "write": 0
      }
    }
  }
}
{
  "type": "step_start",
  "timestamp": 1768657325923,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc310f63001goPBLtsU28DdY7",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc310b1e001riTQzNIaJqZYJm",
    "type": "step-start",
    "snapshot": "9cd19a2edef7613a715ad8039c3dccb57d2f1548"
  }
}
{
  "type": "text",
  "timestamp": 1768657327336,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc310f63002Ty51Va9lAWjXeR",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc310b1e001riTQzNIaJqZYJm",
    "type": "text",
    "text": "[{\"name\": \"reasoning-tools_graph_of_thoughts\", \"arguments\": {\"max_depth\": 5, \"max_nodes\": 20, \"enable_tools\": false, \"problem\": \"There are 26 TODO and FIXME comments in the codebase and no TODO.md file. Which one should I fix?\"}}]",
    "time": {
      "start": 1768657327334,
      "end": 1768657327334
    }
  }
}
{
  "type": "step_finish",
  "timestamp": 1768657327344,
  "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
  "part": {
    "id": "prt_bcc3114e7001qSkRnPLsn2MX6s",
    "sessionID": "ses_433d27aa4ffeLxjUkxr0VzPd3G",
    "messageID": "msg_bcc310b1e001riTQzNIaJqZYJm",
    "type": "step-finish",
    "reason": "stop",
    "snapshot": "9cd19a2edef7613a715ad8039c3dccb57d2f1548",
    "cost": 0.155276,
    "tokens": {
      "input": 77401,
      "output": 79,
      "reasoning": 0,
      "cache": {
        "read": 0,
        "write": 0
      }
    }
  }
}
